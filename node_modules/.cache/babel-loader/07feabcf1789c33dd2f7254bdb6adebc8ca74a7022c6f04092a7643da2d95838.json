{"ast":null,"code":"import { optimizeCallback } from '../../utils/optimizeCallback.js';\nimport { arraySize, broadcastSizes, broadcastTo, get, deepMap } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'map';\nvar dependencies = ['typed'];\nexport var createMap = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Create a new matrix or array with the results of a callback function executed on\n   * each entry of a given matrix/array.\n   *\n   * For each entry of the input,\n   *\n   * the callback is invoked with 2N + 1 arguments:\n   * the N values of the entry, the index at which that entry occurs, and the N full\n   * broadcasted matrix/array being traversed where N is the number of matrices being traversed.\n   * Note that because the matrix/array might be\n   * multidimensional, the \"index\" argument is always an array of numbers giving\n   * the index in each dimension. This is true even for vectors: the \"index\"\n   * argument is an array of length 1, rather than simply a number.\n   *\n   * Syntax:\n   *\n   *    math.map(x, callback)\n   *    math.map(x, y, ..., callback)\n   *\n   * Examples:\n   *\n   *    math.map([1, 2, 3], function(value) {\n   *      return value * value\n   *    })  // returns [1, 4, 9]\n   *    math.map([1, 2], [3, 4], function(a, b) {\n   *     return a + b\n   *    })  // returns [4, 6]\n   *\n   *    // The callback is normally called with three arguments:\n   *    //    callback(value, index, Array)\n   *    // If you want to call with only one argument, use:\n   *    math.map([1, 2, 3], x => math.format(x)) // returns ['1', '2', '3']\n   *    // It can also be called with 2N + 1 arguments: for N arrays\n   *    //    callback(value1, value2, index, BroadcastedArray1, BroadcastedArray2)\n   *\n   * See also:\n   *\n   *    filter, forEach, sort\n   *\n   * @param {Matrix | Array} x    The input to iterate on.\n   * @param {Function} callback\n   *     The function to call (as described above) on each entry of the input\n   * @return {Matrix | array}\n   *     Transformed map of x; always has the same type and shape as x\n   */\n  return typed(name, {\n    'Array, function': _mapArray,\n    'Matrix, function': function Matrix_function(x, callback) {\n      return x.map(callback);\n    },\n    'Array|Matrix, Array|Matrix, ...Array|Matrix|function': (A, B, rest) => _mapMultiple([A, B, ...rest.slice(0, rest.length - 1)], rest[rest.length - 1])\n  });\n\n  /**\n  * Maps over multiple arrays or matrices.\n  *\n  * @param {Array<Array|Matrix>} Arrays - An array of arrays or matrices to map over.\n  * @param {function} multiCallback - The callback function to apply to each element.\n  * @throws {Error} If the last argument is not a callback function.\n  * @returns {Array|Matrix} A new array or matrix with each element being the result of the callback function.\n  *\n  * @example\n  * _mapMultiple([[1, 2, 3], [4, 5, 6]], (a, b) => a + b); // Returns [5, 7, 9]\n  */\n  function _mapMultiple(Arrays, multiCallback) {\n    if (typeof multiCallback !== 'function') {\n      throw new Error('Last argument must be a callback function');\n    }\n    var firstArrayIsMatrix = Arrays[0].isMatrix;\n    var newSize = broadcastSizes(...Arrays.map(M => M.isMatrix ? M.size() : arraySize(M)));\n    var _get = firstArrayIsMatrix ? (matrix, idx) => matrix.get(idx) : get;\n    var broadcastedArrays = firstArrayIsMatrix ? Arrays.map(M => M.isMatrix ? M.create(broadcastTo(M.toArray(), newSize), M.datatype()) : Arrays[0].create(broadcastTo(M.valueOf(), newSize))) : Arrays.map(M => M.isMatrix ? broadcastTo(M.toArray(), newSize) : broadcastTo(M, newSize));\n    var callback;\n    if (typed.isTypedFunction(multiCallback)) {\n      var firstIndex = newSize.map(() => 0);\n      var firstValues = broadcastedArrays.map(array => _get(array, firstIndex));\n      var callbackCase = _getTypedCallbackCase(multiCallback, firstValues, firstIndex, broadcastedArrays);\n      callback = _getLimitedCallback(callbackCase);\n    } else {\n      var numberOfArrays = Arrays.length;\n      var _callbackCase = _getCallbackCase(multiCallback, numberOfArrays);\n      callback = _getLimitedCallback(_callbackCase);\n    }\n    var broadcastedArraysCallback = (x, idx) => callback([x, ...broadcastedArrays.slice(1).map(Array => _get(Array, idx))], idx);\n    if (firstArrayIsMatrix) {\n      return broadcastedArrays[0].map(broadcastedArraysCallback);\n    } else {\n      return _mapArray(broadcastedArrays[0], broadcastedArraysCallback);\n    }\n    function _getLimitedCallback(callbackCase) {\n      switch (callbackCase) {\n        case 0:\n          return x => multiCallback(...x);\n        case 1:\n          return (x, idx) => multiCallback(...x, idx);\n        case 2:\n          return (x, idx) => multiCallback(...x, idx, ...broadcastedArrays);\n      }\n    }\n    function _getCallbackCase(callback, numberOfArrays) {\n      if (callback.length > numberOfArrays + 1) {\n        return 2;\n      }\n      if (callback.length === numberOfArrays + 1) {\n        return 1;\n      }\n      return 0;\n    }\n    function _getTypedCallbackCase(callback, values, idx, arrays) {\n      if (typed.resolve(callback, [...values, idx, ...arrays]) !== null) {\n        return 2;\n      }\n      if (typed.resolve(callback, [...values, idx]) !== null) {\n        return 1;\n      }\n      if (typed.resolve(callback, values) !== null) {\n        return 0;\n      }\n      // this should never happen\n      return 0;\n    }\n  }\n  /**\n  * Map for a multi dimensional array\n  * @param {Array} array\n  * @param {Function} callback\n  * @return {Array}\n  * @private\n  */\n  function _mapArray(array, callback) {\n    var fastCallback = optimizeCallback(callback, array, name);\n    return deepMap(array, fastCallback.fn, fastCallback.isUnary);\n  }\n});","map":{"version":3,"names":["optimizeCallback","arraySize","broadcastSizes","broadcastTo","get","deepMap","factory","name","dependencies","createMap","_ref","typed","_mapArray","Matrix_function","x","callback","map","Array|Matrix, Array|Matrix, ...Array|Matrix|function","A","B","rest","_mapMultiple","slice","length","Arrays","multiCallback","Error","firstArrayIsMatrix","isMatrix","newSize","M","size","_get","matrix","idx","broadcastedArrays","create","toArray","datatype","valueOf","isTypedFunction","firstIndex","firstValues","array","callbackCase","_getTypedCallbackCase","_getLimitedCallback","numberOfArrays","_callbackCase","_getCallbackCase","broadcastedArraysCallback","Array","values","arrays","resolve","fastCallback","fn","isUnary"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/function/matrix/map.js"],"sourcesContent":["import { optimizeCallback } from '../../utils/optimizeCallback.js';\nimport { arraySize, broadcastSizes, broadcastTo, get, deepMap } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'map';\nvar dependencies = ['typed'];\nexport var createMap = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Create a new matrix or array with the results of a callback function executed on\n   * each entry of a given matrix/array.\n   *\n   * For each entry of the input,\n   *\n   * the callback is invoked with 2N + 1 arguments:\n   * the N values of the entry, the index at which that entry occurs, and the N full\n   * broadcasted matrix/array being traversed where N is the number of matrices being traversed.\n   * Note that because the matrix/array might be\n   * multidimensional, the \"index\" argument is always an array of numbers giving\n   * the index in each dimension. This is true even for vectors: the \"index\"\n   * argument is an array of length 1, rather than simply a number.\n   *\n   * Syntax:\n   *\n   *    math.map(x, callback)\n   *    math.map(x, y, ..., callback)\n   *\n   * Examples:\n   *\n   *    math.map([1, 2, 3], function(value) {\n   *      return value * value\n   *    })  // returns [1, 4, 9]\n   *    math.map([1, 2], [3, 4], function(a, b) {\n   *     return a + b\n   *    })  // returns [4, 6]\n   *\n   *    // The callback is normally called with three arguments:\n   *    //    callback(value, index, Array)\n   *    // If you want to call with only one argument, use:\n   *    math.map([1, 2, 3], x => math.format(x)) // returns ['1', '2', '3']\n   *    // It can also be called with 2N + 1 arguments: for N arrays\n   *    //    callback(value1, value2, index, BroadcastedArray1, BroadcastedArray2)\n   *\n   * See also:\n   *\n   *    filter, forEach, sort\n   *\n   * @param {Matrix | Array} x    The input to iterate on.\n   * @param {Function} callback\n   *     The function to call (as described above) on each entry of the input\n   * @return {Matrix | array}\n   *     Transformed map of x; always has the same type and shape as x\n   */\n  return typed(name, {\n    'Array, function': _mapArray,\n    'Matrix, function': function Matrix_function(x, callback) {\n      return x.map(callback);\n    },\n    'Array|Matrix, Array|Matrix, ...Array|Matrix|function': (A, B, rest) => _mapMultiple([A, B, ...rest.slice(0, rest.length - 1)], rest[rest.length - 1])\n  });\n\n  /**\n  * Maps over multiple arrays or matrices.\n  *\n  * @param {Array<Array|Matrix>} Arrays - An array of arrays or matrices to map over.\n  * @param {function} multiCallback - The callback function to apply to each element.\n  * @throws {Error} If the last argument is not a callback function.\n  * @returns {Array|Matrix} A new array or matrix with each element being the result of the callback function.\n  *\n  * @example\n  * _mapMultiple([[1, 2, 3], [4, 5, 6]], (a, b) => a + b); // Returns [5, 7, 9]\n  */\n  function _mapMultiple(Arrays, multiCallback) {\n    if (typeof multiCallback !== 'function') {\n      throw new Error('Last argument must be a callback function');\n    }\n    var firstArrayIsMatrix = Arrays[0].isMatrix;\n    var newSize = broadcastSizes(...Arrays.map(M => M.isMatrix ? M.size() : arraySize(M)));\n    var _get = firstArrayIsMatrix ? (matrix, idx) => matrix.get(idx) : get;\n    var broadcastedArrays = firstArrayIsMatrix ? Arrays.map(M => M.isMatrix ? M.create(broadcastTo(M.toArray(), newSize), M.datatype()) : Arrays[0].create(broadcastTo(M.valueOf(), newSize))) : Arrays.map(M => M.isMatrix ? broadcastTo(M.toArray(), newSize) : broadcastTo(M, newSize));\n    var callback;\n    if (typed.isTypedFunction(multiCallback)) {\n      var firstIndex = newSize.map(() => 0);\n      var firstValues = broadcastedArrays.map(array => _get(array, firstIndex));\n      var callbackCase = _getTypedCallbackCase(multiCallback, firstValues, firstIndex, broadcastedArrays);\n      callback = _getLimitedCallback(callbackCase);\n    } else {\n      var numberOfArrays = Arrays.length;\n      var _callbackCase = _getCallbackCase(multiCallback, numberOfArrays);\n      callback = _getLimitedCallback(_callbackCase);\n    }\n    var broadcastedArraysCallback = (x, idx) => callback([x, ...broadcastedArrays.slice(1).map(Array => _get(Array, idx))], idx);\n    if (firstArrayIsMatrix) {\n      return broadcastedArrays[0].map(broadcastedArraysCallback);\n    } else {\n      return _mapArray(broadcastedArrays[0], broadcastedArraysCallback);\n    }\n    function _getLimitedCallback(callbackCase) {\n      switch (callbackCase) {\n        case 0:\n          return x => multiCallback(...x);\n        case 1:\n          return (x, idx) => multiCallback(...x, idx);\n        case 2:\n          return (x, idx) => multiCallback(...x, idx, ...broadcastedArrays);\n      }\n    }\n    function _getCallbackCase(callback, numberOfArrays) {\n      if (callback.length > numberOfArrays + 1) {\n        return 2;\n      }\n      if (callback.length === numberOfArrays + 1) {\n        return 1;\n      }\n      return 0;\n    }\n    function _getTypedCallbackCase(callback, values, idx, arrays) {\n      if (typed.resolve(callback, [...values, idx, ...arrays]) !== null) {\n        return 2;\n      }\n      if (typed.resolve(callback, [...values, idx]) !== null) {\n        return 1;\n      }\n      if (typed.resolve(callback, values) !== null) {\n        return 0;\n      }\n      // this should never happen\n      return 0;\n    }\n  }\n  /**\n  * Map for a multi dimensional array\n  * @param {Array} array\n  * @param {Function} callback\n  * @return {Array}\n  * @private\n  */\n  function _mapArray(array, callback) {\n    var fastCallback = optimizeCallback(callback, array, name);\n    return deepMap(array, fastCallback.fn, fastCallback.isUnary);\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}