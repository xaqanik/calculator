{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isConstantNode, isOperatorNode, isParenthesisNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { createSubScope } from '../../utils/scope.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs.js';\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Returns true if the expression starts with a constant, under\n   * the current parenthesization:\n   * @param {Node} expression\n   * @param {string} parenthesis\n   * @return {boolean}\n   */\n  function startsWithConstant(expr, parenthesis) {\n    var curNode = expr;\n    if (parenthesis === 'auto') {\n      while (isParenthesisNode(curNode)) curNode = curNode.content;\n    }\n    if (isConstantNode(curNode)) return true;\n    if (isOperatorNode(curNode)) {\n      return startsWithConstant(curNode.args[0], parenthesis);\n    }\n    return false;\n  }\n\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = getPrecedence(root, parenthesis, implicit);\n    var associativity = getAssociativity(root, parenthesis);\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n          default:\n            return true;\n        }\n      });\n    }\n    var result;\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);\n\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          }\n\n          // otherwise, no parens needed\n          result = [false];\n        }\n        break;\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);\n          // is the root node associative with the left hand side\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);\n          // is the root node associative with the right hand side?\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          }\n\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\n          if (latex) {\n            var _rootIdentifier;\n            var lhsIdentifier;\n            var rhsIdentifier;\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n            if (lhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n            if (rhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n          result = [lhsParens, rhsParens];\n        }\n        break;\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = getAssociativity(arg, parenthesis);\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n            return false;\n          });\n        }\n        break;\n    }\n\n    // Handles an edge case of parentheses with implicit multiplication\n    // of ConstantNode.\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\n    // expression, even though they normally wouldn't be printed.\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\n      for (var i = 1; i < result.length; ++i) {\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !isParenthesisNode(args[i - 1]))) {\n          result[i] = true;\n        }\n      }\n    }\n    return result;\n  }\n  class OperatorNode extends Node {\n    /**\n     * @constructor OperatorNode\n     * @extends {Node}\n     * An operator with two arguments, like 2+3\n     *\n     * @param {string} op           Operator name, for example '+'\n     * @param {string} fn           Function name, for example 'add'\n     * @param {Node[]} args         Operator arguments\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\n     */\n    constructor(op, fn, args, implicit, isPercentage) {\n      super();\n      // validate input\n      if (typeof op !== 'string') {\n        throw new TypeError('string expected for parameter \"op\"');\n      }\n      if (typeof fn !== 'string') {\n        throw new TypeError('string expected for parameter \"fn\"');\n      }\n      if (!Array.isArray(args) || !args.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n      }\n      this.implicit = implicit === true;\n      this.isPercentage = isPercentage === true;\n      this.op = op;\n      this.fn = fn;\n      this.args = args || [];\n    }\n    get type() {\n      return name;\n    }\n    get isOperatorNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      // validate fn\n      if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n        if (!math[this.fn]) {\n          throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n        } else {\n          throw new Error('No access to function \"' + this.fn + '\"');\n        }\n      }\n      var fn = getSafeProperty(math, this.fn);\n      var evalArgs = map(this.args, function (arg) {\n        return arg._compile(math, argNames);\n      });\n      if (typeof fn === 'function' && fn.rawArgs === true) {\n        // pass unevaluated parameters (nodes) to the function\n        // \"raw\" evaluation\n        var rawArgs = this.args;\n        return function evalOperatorNode(scope, args, context) {\n          return fn(rawArgs, math, createSubScope(scope, args));\n        };\n      } else if (evalArgs.length === 1) {\n        var evalArg0 = evalArgs[0];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(evalArg0(scope, args, context));\n        };\n      } else if (evalArgs.length === 2) {\n        var _evalArg = evalArgs[0];\n        var evalArg1 = evalArgs[1];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n        };\n      } else {\n        return function evalOperatorNode(scope, args, context) {\n          return fn.apply(null, map(evalArgs, function (evalArg) {\n            return evalArg(scope, args, context);\n          }));\n        };\n      }\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      for (var i = 0; i < this.args.length; i++) {\n        callback(this.args[i], 'args[' + i + ']', this);\n      }\n    }\n\n    /**\n     * Create a new OperatorNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {OperatorNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var args = [];\n      for (var i = 0; i < this.args.length; i++) {\n        args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n      }\n      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {OperatorNode}\n     */\n    clone() {\n      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\n    }\n\n    /**\n     * Check whether this is an unary OperatorNode:\n     * has exactly one argument, like `-a`.\n     * @return {boolean}\n     *     Returns true when an unary operator node, false otherwise.\n     */\n    isUnary() {\n      return this.args.length === 1;\n    }\n\n    /**\n     * Check whether this is a binary OperatorNode:\n     * has exactly two arguments, like `a + b`.\n     * @return {boolean}\n     *     Returns true when a binary operator node, false otherwise.\n     */\n    isBinary() {\n      return this.args.length === 2;\n    }\n\n    /**\n     * Get string representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toString(options);\n        if (parens[0]) {\n          operand = '(' + operand + ')';\n        }\n\n        // for example for \"not\", we want a space between operand and argument\n        var opIsNamed = /[a-zA-Z]+/.test(this.op);\n        if (assoc === 'right') {\n          // prefix operator\n          return this.op + (opIsNamed ? ' ' : '') + operand;\n        } else if (assoc === 'left') {\n          // postfix\n          return operand + (opIsNamed ? ' ' : '') + this.op;\n        }\n\n        // fall back to postfix\n        return operand + this.op;\n      } else if (args.length === 2) {\n        var lhs = args[0].toString(options); // left hand side\n        var rhs = args[1].toString(options); // right hand side\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '(' + lhs + ')';\n        }\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '(' + rhs + ')';\n        }\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + ' ' + rhs;\n        }\n        return lhs + ' ' + this.op + ' ' + rhs;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toString(options);\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '(' + arg + ')';\n          }\n          return arg;\n        });\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join(' ');\n        }\n        return stringifiedArgs.join(' ' + this.op + ' ');\n      } else {\n        // fallback to formatting as a function call\n        return this.fn + '(' + this.args.join(', ') + ')';\n      }\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        op: this.op,\n        fn: this.fn,\n        args: this.args,\n        implicit: this.implicit,\n        isPercentage: this.isPercentage\n      };\n    }\n\n    /**\n     * Instantiate an OperatorNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"OperatorNode\",\n     *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\n     *      \"implicit\": false,\n     *      \"isPercentage\":false}\n     *     ```\n     *     where mathjs is optional\n     * @returns {OperatorNode}\n     */\n    static fromJSON(json) {\n      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\n    }\n\n    /**\n     * Get HTML representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toHTML(options);\n        if (parens[0]) {\n          operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        if (assoc === 'right') {\n          // prefix operator\n          return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n        } else {\n          // postfix when assoc === 'left' or undefined\n          return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + escape(this.op) + '</span>';\n        }\n      } else if (args.length === 2) {\n        // binary operatoes\n        var lhs = args[0].toHTML(options); // left hand side\n        var rhs = args[1].toHTML(options); // right hand side\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\n        }\n        return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n      } else {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toHTML(options);\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n          return arg;\n        });\n        if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\n          }\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n        } else {\n          // fallback to formatting as a function call\n          return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n        }\n      }\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n      var op = latexOperators[this.fn];\n      op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toTex(options);\n        if (parens[0]) {\n          operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n        }\n        if (assoc === 'right') {\n          // prefix operator\n          return op + operand;\n        } else if (assoc === 'left') {\n          // postfix operator\n          return operand + op;\n        }\n\n        // fall back to postfix\n        return operand + op;\n      } else if (args.length === 2) {\n        // binary operators\n        var lhs = args[0]; // left hand side\n        var lhsTex = lhs.toTex(options);\n        if (parens[0]) {\n          lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n        }\n        var rhs = args[1]; // right hand side\n        var rhsTex = rhs.toTex(options);\n        if (parens[1]) {\n          rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n        }\n\n        // handle some exceptions (due to the way LaTeX works)\n        var lhsIdentifier;\n        if (parenthesis === 'keep') {\n          lhsIdentifier = lhs.getIdentifier();\n        } else {\n          // Ignore ParenthesisNodes if in 'keep' mode\n          lhsIdentifier = lhs.getContent().getIdentifier();\n        }\n        switch (this.getIdentifier()) {\n          case 'OperatorNode:divide':\n            // op contains '\\\\frac' at this point\n            return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n          case 'OperatorNode:pow':\n            lhsTex = '{' + lhsTex + '}';\n            rhsTex = '{' + rhsTex + '}';\n            switch (lhsIdentifier) {\n              case 'ConditionalNode': //\n              case 'OperatorNode:divide':\n                lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n            }\n            break;\n          case 'OperatorNode:multiply':\n            if (this.implicit && implicit === 'hide') {\n              return lhsTex + '~' + rhsTex;\n            }\n        }\n        return lhsTex + op + rhsTex;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var texifiedArgs = args.map(function (arg, index) {\n          arg = arg.toTex(options);\n          if (parens[index]) {\n            arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n          }\n          return arg;\n        });\n        if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\n          return texifiedArgs.join('~');\n        }\n        return texifiedArgs.join(op);\n      } else {\n        // fall back to formatting as a function call\n        // as this is a fallback, it doesn't use\n        // fancy function names\n        return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n          return arg.toTex(options);\n        }).join(',') + '\\\\right)';\n      }\n    }\n\n    /**\n     * Get identifier.\n     * @return {string}\n     */\n    getIdentifier() {\n      return this.type + ':' + this.fn;\n    }\n  }\n  _defineProperty(OperatorNode, \"name\", name);\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","isConstantNode","isOperatorNode","isParenthesisNode","map","createSubScope","escape","getSafeProperty","isSafeMethod","getAssociativity","getPrecedence","isAssociativeWith","properties","latexOperators","factory","name","dependencies","createOperatorNode","_ref","Node","startsWithConstant","expr","parenthesis","curNode","content","args","calculateNecessaryParentheses","root","implicit","latex","precedence","associativity","length","getIdentifier","arg","getContent","type","result","operandPrecedence","operandIdentifier","rootIdentifier","latexLeftParens","latexParens","lhsParens","lhsPrecedence","assocWithLhs","rhsParens","rhsPrecedence","assocWithRhs","_rootIdentifier","lhsIdentifier","rhsIdentifier","latexRightParens","argPrecedence","assocWithArg","argAssociativity","i","OperatorNode","constructor","op","fn","isPercentage","TypeError","Array","isArray","every","_compile","math","argNames","Error","evalArgs","rawArgs","evalOperatorNode","scope","context","evalArg0","_evalArg","evalArg1","apply","evalArg","forEach","callback","_ifNode","clone","slice","isUnary","isBinary","_toString","options","parens","assoc","operand","toString","opIsNamed","test","lhs","rhs","stringifiedArgs","index","join","toJSON","mathjs","fromJSON","json","_toHTML","toHTML","_toTex","toTex","concat","lhsTex","rhsTex","texifiedArgs","isClass"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/expression/node/OperatorNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isConstantNode, isOperatorNode, isParenthesisNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { createSubScope } from '../../utils/scope.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs.js';\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Returns true if the expression starts with a constant, under\n   * the current parenthesization:\n   * @param {Node} expression\n   * @param {string} parenthesis\n   * @return {boolean}\n   */\n  function startsWithConstant(expr, parenthesis) {\n    var curNode = expr;\n    if (parenthesis === 'auto') {\n      while (isParenthesisNode(curNode)) curNode = curNode.content;\n    }\n    if (isConstantNode(curNode)) return true;\n    if (isOperatorNode(curNode)) {\n      return startsWithConstant(curNode.args[0], parenthesis);\n    }\n    return false;\n  }\n\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = getPrecedence(root, parenthesis, implicit);\n    var associativity = getAssociativity(root, parenthesis);\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n          default:\n            return true;\n        }\n      });\n    }\n    var result;\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);\n\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          }\n\n          // otherwise, no parens needed\n          result = [false];\n        }\n        break;\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);\n          // is the root node associative with the left hand side\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);\n          // is the root node associative with the right hand side?\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          }\n\n          // handle special cases for LaTeX, where some of the parentheses aren't needed\n          if (latex) {\n            var _rootIdentifier;\n            var lhsIdentifier;\n            var rhsIdentifier;\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n            if (lhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n            if (rhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n          result = [lhsParens, rhsParens];\n        }\n        break;\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = getAssociativity(arg, parenthesis);\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n            return false;\n          });\n        }\n        break;\n    }\n\n    // Handles an edge case of parentheses with implicit multiplication\n    // of ConstantNode.\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\n    // expression, even though they normally wouldn't be printed.\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\n      for (var i = 1; i < result.length; ++i) {\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !isParenthesisNode(args[i - 1]))) {\n          result[i] = true;\n        }\n      }\n    }\n    return result;\n  }\n  class OperatorNode extends Node {\n    /**\n     * @constructor OperatorNode\n     * @extends {Node}\n     * An operator with two arguments, like 2+3\n     *\n     * @param {string} op           Operator name, for example '+'\n     * @param {string} fn           Function name, for example 'add'\n     * @param {Node[]} args         Operator arguments\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\n     */\n    constructor(op, fn, args, implicit, isPercentage) {\n      super();\n      // validate input\n      if (typeof op !== 'string') {\n        throw new TypeError('string expected for parameter \"op\"');\n      }\n      if (typeof fn !== 'string') {\n        throw new TypeError('string expected for parameter \"fn\"');\n      }\n      if (!Array.isArray(args) || !args.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n      }\n      this.implicit = implicit === true;\n      this.isPercentage = isPercentage === true;\n      this.op = op;\n      this.fn = fn;\n      this.args = args || [];\n    }\n    get type() {\n      return name;\n    }\n    get isOperatorNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      // validate fn\n      if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n        if (!math[this.fn]) {\n          throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n        } else {\n          throw new Error('No access to function \"' + this.fn + '\"');\n        }\n      }\n      var fn = getSafeProperty(math, this.fn);\n      var evalArgs = map(this.args, function (arg) {\n        return arg._compile(math, argNames);\n      });\n      if (typeof fn === 'function' && fn.rawArgs === true) {\n        // pass unevaluated parameters (nodes) to the function\n        // \"raw\" evaluation\n        var rawArgs = this.args;\n        return function evalOperatorNode(scope, args, context) {\n          return fn(rawArgs, math, createSubScope(scope, args));\n        };\n      } else if (evalArgs.length === 1) {\n        var evalArg0 = evalArgs[0];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(evalArg0(scope, args, context));\n        };\n      } else if (evalArgs.length === 2) {\n        var _evalArg = evalArgs[0];\n        var evalArg1 = evalArgs[1];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n        };\n      } else {\n        return function evalOperatorNode(scope, args, context) {\n          return fn.apply(null, map(evalArgs, function (evalArg) {\n            return evalArg(scope, args, context);\n          }));\n        };\n      }\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      for (var i = 0; i < this.args.length; i++) {\n        callback(this.args[i], 'args[' + i + ']', this);\n      }\n    }\n\n    /**\n     * Create a new OperatorNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {OperatorNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var args = [];\n      for (var i = 0; i < this.args.length; i++) {\n        args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n      }\n      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {OperatorNode}\n     */\n    clone() {\n      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\n    }\n\n    /**\n     * Check whether this is an unary OperatorNode:\n     * has exactly one argument, like `-a`.\n     * @return {boolean}\n     *     Returns true when an unary operator node, false otherwise.\n     */\n    isUnary() {\n      return this.args.length === 1;\n    }\n\n    /**\n     * Check whether this is a binary OperatorNode:\n     * has exactly two arguments, like `a + b`.\n     * @return {boolean}\n     *     Returns true when a binary operator node, false otherwise.\n     */\n    isBinary() {\n      return this.args.length === 2;\n    }\n\n    /**\n     * Get string representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toString(options);\n        if (parens[0]) {\n          operand = '(' + operand + ')';\n        }\n\n        // for example for \"not\", we want a space between operand and argument\n        var opIsNamed = /[a-zA-Z]+/.test(this.op);\n        if (assoc === 'right') {\n          // prefix operator\n          return this.op + (opIsNamed ? ' ' : '') + operand;\n        } else if (assoc === 'left') {\n          // postfix\n          return operand + (opIsNamed ? ' ' : '') + this.op;\n        }\n\n        // fall back to postfix\n        return operand + this.op;\n      } else if (args.length === 2) {\n        var lhs = args[0].toString(options); // left hand side\n        var rhs = args[1].toString(options); // right hand side\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '(' + lhs + ')';\n        }\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '(' + rhs + ')';\n        }\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + ' ' + rhs;\n        }\n        return lhs + ' ' + this.op + ' ' + rhs;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toString(options);\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '(' + arg + ')';\n          }\n          return arg;\n        });\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join(' ');\n        }\n        return stringifiedArgs.join(' ' + this.op + ' ');\n      } else {\n        // fallback to formatting as a function call\n        return this.fn + '(' + this.args.join(', ') + ')';\n      }\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        op: this.op,\n        fn: this.fn,\n        args: this.args,\n        implicit: this.implicit,\n        isPercentage: this.isPercentage\n      };\n    }\n\n    /**\n     * Instantiate an OperatorNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"OperatorNode\",\n     *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\n     *      \"implicit\": false,\n     *      \"isPercentage\":false}\n     *     ```\n     *     where mathjs is optional\n     * @returns {OperatorNode}\n     */\n    static fromJSON(json) {\n      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\n    }\n\n    /**\n     * Get HTML representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toHTML(options);\n        if (parens[0]) {\n          operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        if (assoc === 'right') {\n          // prefix operator\n          return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n        } else {\n          // postfix when assoc === 'left' or undefined\n          return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + escape(this.op) + '</span>';\n        }\n      } else if (args.length === 2) {\n        // binary operatoes\n        var lhs = args[0].toHTML(options); // left hand side\n        var rhs = args[1].toHTML(options); // right hand side\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\n        }\n        return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n      } else {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toHTML(options);\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n          return arg;\n        });\n        if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\n          }\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n        } else {\n          // fallback to formatting as a function call\n          return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n        }\n      }\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n      var op = latexOperators[this.fn];\n      op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toTex(options);\n        if (parens[0]) {\n          operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n        }\n        if (assoc === 'right') {\n          // prefix operator\n          return op + operand;\n        } else if (assoc === 'left') {\n          // postfix operator\n          return operand + op;\n        }\n\n        // fall back to postfix\n        return operand + op;\n      } else if (args.length === 2) {\n        // binary operators\n        var lhs = args[0]; // left hand side\n        var lhsTex = lhs.toTex(options);\n        if (parens[0]) {\n          lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n        }\n        var rhs = args[1]; // right hand side\n        var rhsTex = rhs.toTex(options);\n        if (parens[1]) {\n          rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n        }\n\n        // handle some exceptions (due to the way LaTeX works)\n        var lhsIdentifier;\n        if (parenthesis === 'keep') {\n          lhsIdentifier = lhs.getIdentifier();\n        } else {\n          // Ignore ParenthesisNodes if in 'keep' mode\n          lhsIdentifier = lhs.getContent().getIdentifier();\n        }\n        switch (this.getIdentifier()) {\n          case 'OperatorNode:divide':\n            // op contains '\\\\frac' at this point\n            return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n          case 'OperatorNode:pow':\n            lhsTex = '{' + lhsTex + '}';\n            rhsTex = '{' + rhsTex + '}';\n            switch (lhsIdentifier) {\n              case 'ConditionalNode': //\n              case 'OperatorNode:divide':\n                lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n            }\n            break;\n          case 'OperatorNode:multiply':\n            if (this.implicit && implicit === 'hide') {\n              return lhsTex + '~' + rhsTex;\n            }\n        }\n        return lhsTex + op + rhsTex;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var texifiedArgs = args.map(function (arg, index) {\n          arg = arg.toTex(options);\n          if (parens[index]) {\n            arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n          }\n          return arg;\n        });\n        if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\n          return texifiedArgs.join('~');\n        }\n        return texifiedArgs.join(op);\n      } else {\n        // fall back to formatting as a function call\n        // as this is a fallback, it doesn't use\n        // fancy function names\n        return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n          return arg.toTex(options);\n        }).join(',') + '\\\\right)';\n      }\n    }\n\n    /**\n     * Get identifier.\n     * @return {string}\n     */\n    getIdentifier() {\n      return this.type + ':' + this.fn;\n    }\n  }\n  _defineProperty(OperatorNode, \"name\", name);\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}