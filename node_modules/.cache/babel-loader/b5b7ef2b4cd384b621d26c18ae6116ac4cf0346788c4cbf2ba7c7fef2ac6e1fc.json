{"ast":null,"code":"import { isNumber } from '../../utils/is.js';\nimport { flatten } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'quantileSeq';\nvar dependencies = ['typed', '?bignumber', 'add', 'subtract', 'divide', 'multiply', 'partitionSelect', 'compare', 'isInteger', 'smaller', 'smallerEq', 'larger', 'mapSlices'];\nexport var createQuantileSeq = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    bignumber,\n    add,\n    subtract,\n    divide,\n    multiply,\n    partitionSelect,\n    compare,\n    isInteger,\n    smaller,\n    smallerEq,\n    larger,\n    mapSlices\n  } = _ref;\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a multidimensional array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n  return typed(name, {\n    'Array | Matrix, number | BigNumber': (data, p) => _quantileSeqProbNumber(data, p, false),\n    'Array | Matrix, number | BigNumber, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber),\n    'Array | Matrix, number | BigNumber, boolean': _quantileSeqProbNumber,\n    'Array | Matrix, number | BigNumber, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber),\n    'Array | Matrix, Array | Matrix': (data, p) => _quantileSeqProbCollection(data, p, false),\n    'Array | Matrix, Array | Matrix, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection),\n    'Array | Matrix, Array | Matrix, boolean': _quantileSeqProbCollection,\n    'Array | Matrix, Array | Matrix, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection)\n  });\n  function _quantileSeqDim(data, prob, sorted, dim, fn) {\n    return mapSlices(data, dim, x => fn(x, prob, sorted));\n  }\n  function _quantileSeqProbNumber(data, probOrN, sorted) {\n    var probArr;\n    var dataArr = data.valueOf();\n    if (smaller(probOrN, 0)) {\n      throw new Error('N/prob must be non-negative');\n    }\n    if (smallerEq(probOrN, 1)) {\n      // quantileSeq([a, b, c, d, ...], prob[,sorted])\n      return isNumber(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber(_quantileSeq(dataArr, probOrN, sorted));\n    }\n    if (larger(probOrN, 1)) {\n      // quantileSeq([a, b, c, d, ...], N[,sorted])\n      if (!isInteger(probOrN)) {\n        throw new Error('N must be a positive integer');\n      }\n\n      // largest possible Array length is 2^32-1\n      // 2^32 < 10^15, thus safe conversion guaranteed\n      if (larger(probOrN, 4294967295)) {\n        throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n      }\n      var nPlusOne = add(probOrN, 1);\n      probArr = [];\n      for (var i = 0; smaller(i, probOrN); i++) {\n        var prob = divide(i + 1, nPlusOne);\n        probArr.push(_quantileSeq(dataArr, prob, sorted));\n      }\n      return isNumber(probOrN) ? probArr : bignumber(probArr);\n    }\n  }\n\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array, Matrix} array\n   * @param {Array, Matrix} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n\n  function _quantileSeqProbCollection(data, probOrN, sorted) {\n    var dataArr = data.valueOf();\n    // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n    var probOrNArr = probOrN.valueOf();\n    var probArr = [];\n    for (var i = 0; i < probOrNArr.length; ++i) {\n      probArr.push(_quantileSeq(dataArr, probOrNArr[i], sorted));\n    }\n    return probArr;\n  }\n\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n  function _quantileSeq(array, prob, sorted) {\n    var flat = flatten(array);\n    var len = flat.length;\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n    var index = isNumber(prob) ? prob * (len - 1) : prob.times(len - 1);\n    var integerPart = isNumber(prob) ? Math.floor(index) : index.floor().toNumber();\n    var fracPart = isNumber(prob) ? index % 1 : index.minus(integerPart);\n    if (isInteger(index)) {\n      return sorted ? flat[index] : partitionSelect(flat, isNumber(prob) ? index : index.valueOf());\n    }\n    var left;\n    var right;\n    if (sorted) {\n      left = flat[integerPart];\n      right = flat[integerPart + 1];\n    } else {\n      right = partitionSelect(flat, integerPart + 1);\n\n      // max of partition is kth largest\n      left = flat[integerPart];\n      for (var i = 0; i < integerPart; ++i) {\n        if (compare(flat[i], left) > 0) {\n          left = flat[i];\n        }\n      }\n    }\n    // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n    return add(multiply(left, subtract(1, fracPart)), multiply(right, fracPart));\n  }\n});","map":{"version":3,"names":["isNumber","flatten","factory","name","dependencies","createQuantileSeq","_ref","typed","bignumber","add","subtract","divide","multiply","partitionSelect","compare","isInteger","smaller","smallerEq","larger","mapSlices","Array | Matrix, number | BigNumber","data","p","_quantileSeqProbNumber","Array | Matrix, number | BigNumber, number","prob","dim","_quantileSeqDim","Array | Matrix, number | BigNumber, boolean, number","sorted","Array | Matrix, Array | Matrix","_quantileSeqProbCollection","Array | Matrix, Array | Matrix, number","Array | Matrix, Array | Matrix, boolean, number","fn","x","probOrN","probArr","dataArr","valueOf","Error","_quantileSeq","nPlusOne","i","push","probOrNArr","length","array","flat","len","index","times","integerPart","Math","floor","toNumber","fracPart","minus","left","right"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js"],"sourcesContent":["import { isNumber } from '../../utils/is.js';\nimport { flatten } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'quantileSeq';\nvar dependencies = ['typed', '?bignumber', 'add', 'subtract', 'divide', 'multiply', 'partitionSelect', 'compare', 'isInteger', 'smaller', 'smallerEq', 'larger', 'mapSlices'];\nexport var createQuantileSeq = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    bignumber,\n    add,\n    subtract,\n    divide,\n    multiply,\n    partitionSelect,\n    compare,\n    isInteger,\n    smaller,\n    smallerEq,\n    larger,\n    mapSlices\n  } = _ref;\n  /**\n   * Compute the prob order quantile of a matrix or a list with values.\n   * The sequence is sorted and the middle value is returned.\n   * Supported types of sequence values are: Number, BigNumber, Unit\n   * Supported types of probability are: Number, BigNumber\n   *\n   * In case of a multidimensional array or matrix, the prob order quantile\n   * of all elements will be calculated.\n   *\n   * Syntax:\n   *\n   *     math.quantileSeq(A, prob[, sorted])\n   *     math.quantileSeq(A, [prob1, prob2, ...][, sorted])\n   *     math.quantileSeq(A, N[, sorted])\n   *\n   * Examples:\n   *\n   *     math.quantileSeq([3, -1, 5, 7], 0.5)         // returns 4\n   *     math.quantileSeq([3, -1, 5, 7], [1/3, 2/3])  // returns [3, 5]\n   *     math.quantileSeq([3, -1, 5, 7], 2)           // returns [3, 5]\n   *     math.quantileSeq([-1, 3, 5, 7], 0.5, true)   // returns 4\n   *\n   * See also:\n   *\n   *     median, mean, min, max, sum, prod, std, variance\n   *\n   * @param {Array, Matrix} data                A single matrix or Array\n   * @param {Number, BigNumber, Array} probOrN  prob is the order of the quantile, while N is\n   *                                            the amount of evenly distributed steps of\n   *                                            probabilities; only one of these options can\n   *                                            be provided\n   * @param {Boolean} sorted=false              is data sorted in ascending order\n   * @return {Number, BigNumber, Unit, Array}   Quantile(s)\n   */\n  return typed(name, {\n    'Array | Matrix, number | BigNumber': (data, p) => _quantileSeqProbNumber(data, p, false),\n    'Array | Matrix, number | BigNumber, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber),\n    'Array | Matrix, number | BigNumber, boolean': _quantileSeqProbNumber,\n    'Array | Matrix, number | BigNumber, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber),\n    'Array | Matrix, Array | Matrix': (data, p) => _quantileSeqProbCollection(data, p, false),\n    'Array | Matrix, Array | Matrix, number': (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection),\n    'Array | Matrix, Array | Matrix, boolean': _quantileSeqProbCollection,\n    'Array | Matrix, Array | Matrix, boolean, number': (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection)\n  });\n  function _quantileSeqDim(data, prob, sorted, dim, fn) {\n    return mapSlices(data, dim, x => fn(x, prob, sorted));\n  }\n  function _quantileSeqProbNumber(data, probOrN, sorted) {\n    var probArr;\n    var dataArr = data.valueOf();\n    if (smaller(probOrN, 0)) {\n      throw new Error('N/prob must be non-negative');\n    }\n    if (smallerEq(probOrN, 1)) {\n      // quantileSeq([a, b, c, d, ...], prob[,sorted])\n      return isNumber(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber(_quantileSeq(dataArr, probOrN, sorted));\n    }\n    if (larger(probOrN, 1)) {\n      // quantileSeq([a, b, c, d, ...], N[,sorted])\n      if (!isInteger(probOrN)) {\n        throw new Error('N must be a positive integer');\n      }\n\n      // largest possible Array length is 2^32-1\n      // 2^32 < 10^15, thus safe conversion guaranteed\n      if (larger(probOrN, 4294967295)) {\n        throw new Error('N must be less than or equal to 2^32-1, as that is the maximum length of an Array');\n      }\n      var nPlusOne = add(probOrN, 1);\n      probArr = [];\n      for (var i = 0; smaller(i, probOrN); i++) {\n        var prob = divide(i + 1, nPlusOne);\n        probArr.push(_quantileSeq(dataArr, prob, sorted));\n      }\n      return isNumber(probOrN) ? probArr : bignumber(probArr);\n    }\n  }\n\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array, Matrix} array\n   * @param {Array, Matrix} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n\n  function _quantileSeqProbCollection(data, probOrN, sorted) {\n    var dataArr = data.valueOf();\n    // quantileSeq([a, b, c, d, ...], [prob1, prob2, ...][,sorted])\n    var probOrNArr = probOrN.valueOf();\n    var probArr = [];\n    for (var i = 0; i < probOrNArr.length; ++i) {\n      probArr.push(_quantileSeq(dataArr, probOrNArr[i], sorted));\n    }\n    return probArr;\n  }\n\n  /**\n   * Calculate the prob order quantile of an n-dimensional array.\n   *\n   * @param {Array} array\n   * @param {Number, BigNumber} prob\n   * @param {Boolean} sorted\n   * @return {Number, BigNumber, Unit} prob order quantile\n   * @private\n   */\n  function _quantileSeq(array, prob, sorted) {\n    var flat = flatten(array);\n    var len = flat.length;\n    if (len === 0) {\n      throw new Error('Cannot calculate quantile of an empty sequence');\n    }\n    var index = isNumber(prob) ? prob * (len - 1) : prob.times(len - 1);\n    var integerPart = isNumber(prob) ? Math.floor(index) : index.floor().toNumber();\n    var fracPart = isNumber(prob) ? index % 1 : index.minus(integerPart);\n    if (isInteger(index)) {\n      return sorted ? flat[index] : partitionSelect(flat, isNumber(prob) ? index : index.valueOf());\n    }\n    var left;\n    var right;\n    if (sorted) {\n      left = flat[integerPart];\n      right = flat[integerPart + 1];\n    } else {\n      right = partitionSelect(flat, integerPart + 1);\n\n      // max of partition is kth largest\n      left = flat[integerPart];\n      for (var i = 0; i < integerPart; ++i) {\n        if (compare(flat[i], left) > 0) {\n          left = flat[i];\n        }\n      }\n    }\n    // Q(prob) = (1-f)*A[floor(index)] + f*A[floor(index)+1]\n    return add(multiply(left, subtract(1, fracPart)), multiply(right, fracPart));\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}