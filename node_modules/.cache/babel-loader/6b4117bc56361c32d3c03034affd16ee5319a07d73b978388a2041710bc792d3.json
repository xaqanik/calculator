{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { isFunctionAssignmentNode, isSymbolNode } from '../../utils/is.js';\nimport { createMap } from '../../function/matrix/map.js';\nimport { compileInlineExpression } from './utils/compileInlineExpression.js';\nimport { createTransformCallback } from './utils/transformCallback.js';\nvar name = 'map';\nvar dependencies = ['typed'];\nexport var createMapTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Attach a transform function to math.map\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  var map = createMap({\n    typed\n  });\n  var transformCallback = createTransformCallback({\n    typed\n  });\n  function mapTransform(args, math, scope) {\n    if (args.length === 0) {\n      return map();\n    }\n    if (args.length === 1) {\n      return map(args[0]);\n    }\n    var N = args.length - 1;\n    var X = args.slice(0, N);\n    var callback = args[N];\n    X = X.map(arg => _compileAndEvaluate(arg, scope));\n    if (callback) {\n      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = _compileAndEvaluate(callback, scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(callback, math, scope);\n      }\n    }\n    return map(...X, transformCallback(callback, N));\n    function _compileAndEvaluate(arg, scope) {\n      return arg.compile().evaluate(scope);\n    }\n  }\n  mapTransform.rawArgs = true;\n  return mapTransform;\n}, {\n  isTransformFunction: true\n});","map":{"version":3,"names":["factory","isFunctionAssignmentNode","isSymbolNode","createMap","compileInlineExpression","createTransformCallback","name","dependencies","createMapTransform","_ref","typed","map","transformCallback","mapTransform","args","math","scope","length","N","X","slice","callback","arg","_compileAndEvaluate","compile","evaluate","rawArgs","isTransformFunction"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/expression/transform/map.transform.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { isFunctionAssignmentNode, isSymbolNode } from '../../utils/is.js';\nimport { createMap } from '../../function/matrix/map.js';\nimport { compileInlineExpression } from './utils/compileInlineExpression.js';\nimport { createTransformCallback } from './utils/transformCallback.js';\nvar name = 'map';\nvar dependencies = ['typed'];\nexport var createMapTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Attach a transform function to math.map\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  var map = createMap({\n    typed\n  });\n  var transformCallback = createTransformCallback({\n    typed\n  });\n  function mapTransform(args, math, scope) {\n    if (args.length === 0) {\n      return map();\n    }\n    if (args.length === 1) {\n      return map(args[0]);\n    }\n    var N = args.length - 1;\n    var X = args.slice(0, N);\n    var callback = args[N];\n    X = X.map(arg => _compileAndEvaluate(arg, scope));\n    if (callback) {\n      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = _compileAndEvaluate(callback, scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(callback, math, scope);\n      }\n    }\n    return map(...X, transformCallback(callback, N));\n    function _compileAndEvaluate(arg, scope) {\n      return arg.compile().evaluate(scope);\n    }\n  }\n  mapTransform.rawArgs = true;\n  return mapTransform;\n}, {\n  isTransformFunction: true\n});"],"mappings":"AAAA,SAASA,OAAO,QAAQ,wBAAwB;AAChD,SAASC,wBAAwB,EAAEC,YAAY,QAAQ,mBAAmB;AAC1E,SAASC,SAAS,QAAQ,8BAA8B;AACxD,SAASC,uBAAuB,QAAQ,oCAAoC;AAC5E,SAASC,uBAAuB,QAAQ,8BAA8B;AACtE,IAAIC,IAAI,GAAG,KAAK;AAChB,IAAIC,YAAY,GAAG,CAAC,OAAO,CAAC;AAC5B,OAAO,IAAIC,kBAAkB,GAAG,eAAeR,OAAO,CAACM,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EACjF,IAAI;IACFC;EACF,CAAC,GAAGD,IAAI;EACR;AACF;AACA;AACA;AACA;AACA;EACE,IAAIE,GAAG,GAAGR,SAAS,CAAC;IAClBO;EACF,CAAC,CAAC;EACF,IAAIE,iBAAiB,GAAGP,uBAAuB,CAAC;IAC9CK;EACF,CAAC,CAAC;EACF,SAASG,YAAYA,CAACC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;IACvC,IAAIF,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;MACrB,OAAON,GAAG,CAAC,CAAC;IACd;IACA,IAAIG,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;MACrB,OAAON,GAAG,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC;IACrB;IACA,IAAII,CAAC,GAAGJ,IAAI,CAACG,MAAM,GAAG,CAAC;IACvB,IAAIE,CAAC,GAAGL,IAAI,CAACM,KAAK,CAAC,CAAC,EAAEF,CAAC,CAAC;IACxB,IAAIG,QAAQ,GAAGP,IAAI,CAACI,CAAC,CAAC;IACtBC,CAAC,GAAGA,CAAC,CAACR,GAAG,CAACW,GAAG,IAAIC,mBAAmB,CAACD,GAAG,EAAEN,KAAK,CAAC,CAAC;IACjD,IAAIK,QAAQ,EAAE;MACZ,IAAInB,YAAY,CAACmB,QAAQ,CAAC,IAAIpB,wBAAwB,CAACoB,QAAQ,CAAC,EAAE;QAChE;QACAA,QAAQ,GAAGE,mBAAmB,CAACF,QAAQ,EAAEL,KAAK,CAAC;MACjD,CAAC,MAAM;QACL;QACAK,QAAQ,GAAGjB,uBAAuB,CAACiB,QAAQ,EAAEN,IAAI,EAAEC,KAAK,CAAC;MAC3D;IACF;IACA,OAAOL,GAAG,CAAC,GAAGQ,CAAC,EAAEP,iBAAiB,CAACS,QAAQ,EAAEH,CAAC,CAAC,CAAC;IAChD,SAASK,mBAAmBA,CAACD,GAAG,EAAEN,KAAK,EAAE;MACvC,OAAOM,GAAG,CAACE,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACT,KAAK,CAAC;IACtC;EACF;EACAH,YAAY,CAACa,OAAO,GAAG,IAAI;EAC3B,OAAOb,YAAY;AACrB,CAAC,EAAE;EACDc,mBAAmB,EAAE;AACvB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}