{"ast":null,"code":"import { createForEach } from '../../function/matrix/forEach.js';\nimport { createTransformCallback } from './utils/transformCallback.js';\nimport { factory } from '../../utils/factory.js';\nimport { isFunctionAssignmentNode, isSymbolNode } from '../../utils/is.js';\nimport { compileInlineExpression } from './utils/compileInlineExpression.js';\nvar name = 'forEach';\nvar dependencies = ['typed'];\nexport var createForEachTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Attach a transform function to math.forEach\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  var forEach = createForEach({\n    typed\n  });\n  var transformCallback = createTransformCallback({\n    typed\n  });\n  function forEachTransform(args, math, scope) {\n    if (args.length === 0) {\n      return forEach();\n    }\n    var x = args[0];\n    if (args.length === 1) {\n      return forEach(x);\n    }\n    var N = args.length - 1;\n    var callback = args[N];\n    if (x) {\n      x = _compileAndEvaluate(x, scope);\n    }\n    if (callback) {\n      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = _compileAndEvaluate(callback, scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(callback, math, scope);\n      }\n    }\n    return forEach(x, transformCallback(callback, N));\n  }\n  forEachTransform.rawArgs = true;\n  function _compileAndEvaluate(arg, scope) {\n    return arg.compile().evaluate(scope);\n  }\n  return forEachTransform;\n}, {\n  isTransformFunction: true\n});","map":{"version":3,"names":["createForEach","createTransformCallback","factory","isFunctionAssignmentNode","isSymbolNode","compileInlineExpression","name","dependencies","createForEachTransform","_ref","typed","forEach","transformCallback","forEachTransform","args","math","scope","length","x","N","callback","_compileAndEvaluate","rawArgs","arg","compile","evaluate","isTransformFunction"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js"],"sourcesContent":["import { createForEach } from '../../function/matrix/forEach.js';\nimport { createTransformCallback } from './utils/transformCallback.js';\nimport { factory } from '../../utils/factory.js';\nimport { isFunctionAssignmentNode, isSymbolNode } from '../../utils/is.js';\nimport { compileInlineExpression } from './utils/compileInlineExpression.js';\nvar name = 'forEach';\nvar dependencies = ['typed'];\nexport var createForEachTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Attach a transform function to math.forEach\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  var forEach = createForEach({\n    typed\n  });\n  var transformCallback = createTransformCallback({\n    typed\n  });\n  function forEachTransform(args, math, scope) {\n    if (args.length === 0) {\n      return forEach();\n    }\n    var x = args[0];\n    if (args.length === 1) {\n      return forEach(x);\n    }\n    var N = args.length - 1;\n    var callback = args[N];\n    if (x) {\n      x = _compileAndEvaluate(x, scope);\n    }\n    if (callback) {\n      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = _compileAndEvaluate(callback, scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(callback, math, scope);\n      }\n    }\n    return forEach(x, transformCallback(callback, N));\n  }\n  forEachTransform.rawArgs = true;\n  function _compileAndEvaluate(arg, scope) {\n    return arg.compile().evaluate(scope);\n  }\n  return forEachTransform;\n}, {\n  isTransformFunction: true\n});"],"mappings":"AAAA,SAASA,aAAa,QAAQ,kCAAkC;AAChE,SAASC,uBAAuB,QAAQ,8BAA8B;AACtE,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,wBAAwB,EAAEC,YAAY,QAAQ,mBAAmB;AAC1E,SAASC,uBAAuB,QAAQ,oCAAoC;AAC5E,IAAIC,IAAI,GAAG,SAAS;AACpB,IAAIC,YAAY,GAAG,CAAC,OAAO,CAAC;AAC5B,OAAO,IAAIC,sBAAsB,GAAG,eAAeN,OAAO,CAACI,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EACrF,IAAI;IACFC;EACF,CAAC,GAAGD,IAAI;EACR;AACF;AACA;AACA;AACA;AACA;EACE,IAAIE,OAAO,GAAGX,aAAa,CAAC;IAC1BU;EACF,CAAC,CAAC;EACF,IAAIE,iBAAiB,GAAGX,uBAAuB,CAAC;IAC9CS;EACF,CAAC,CAAC;EACF,SAASG,gBAAgBA,CAACC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;IAC3C,IAAIF,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;MACrB,OAAON,OAAO,CAAC,CAAC;IAClB;IACA,IAAIO,CAAC,GAAGJ,IAAI,CAAC,CAAC,CAAC;IACf,IAAIA,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;MACrB,OAAON,OAAO,CAACO,CAAC,CAAC;IACnB;IACA,IAAIC,CAAC,GAAGL,IAAI,CAACG,MAAM,GAAG,CAAC;IACvB,IAAIG,QAAQ,GAAGN,IAAI,CAACK,CAAC,CAAC;IACtB,IAAID,CAAC,EAAE;MACLA,CAAC,GAAGG,mBAAmB,CAACH,CAAC,EAAEF,KAAK,CAAC;IACnC;IACA,IAAII,QAAQ,EAAE;MACZ,IAAIhB,YAAY,CAACgB,QAAQ,CAAC,IAAIjB,wBAAwB,CAACiB,QAAQ,CAAC,EAAE;QAChE;QACAA,QAAQ,GAAGC,mBAAmB,CAACD,QAAQ,EAAEJ,KAAK,CAAC;MACjD,CAAC,MAAM;QACL;QACAI,QAAQ,GAAGf,uBAAuB,CAACe,QAAQ,EAAEL,IAAI,EAAEC,KAAK,CAAC;MAC3D;IACF;IACA,OAAOL,OAAO,CAACO,CAAC,EAAEN,iBAAiB,CAACQ,QAAQ,EAAED,CAAC,CAAC,CAAC;EACnD;EACAN,gBAAgB,CAACS,OAAO,GAAG,IAAI;EAC/B,SAASD,mBAAmBA,CAACE,GAAG,EAAEP,KAAK,EAAE;IACvC,OAAOO,GAAG,CAACC,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACT,KAAK,CAAC;EACtC;EACA,OAAOH,gBAAgB;AACzB,CAAC,EAAE;EACDa,mBAAmB,EAAE;AACvB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}