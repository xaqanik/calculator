{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nimport { isUnit, isNumber, isBigNumber } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'solveODE';\nvar dependencies = ['typed', 'add', 'subtract', 'multiply', 'divide', 'max', 'map', 'abs', 'isPositive', 'isNegative', 'larger', 'smaller', 'matrix', 'bignumber', 'unaryMinus'];\nexport var createSolveODE = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    subtract,\n    multiply,\n    divide,\n    max,\n    map,\n    abs,\n    isPositive,\n    isNegative,\n    larger,\n    smaller,\n    matrix,\n    bignumber,\n    unaryMinus\n  } = _ref;\n  /**\n     * Numerical Integration of Ordinary Differential Equations\n     *\n     * Two variable step methods are provided:\n     * - \"RK23\": Bogacki–Shampine method\n     * - \"RK45\": Dormand-Prince method RK5(4)7M (default)\n     *\n     * The arguments are expected as follows.\n     *\n     * - `func` should be the forcing function `f(t, y)`\n     * - `tspan` should be a vector of two numbers or units `[tStart, tEnd]`\n     * - `y0` the initial state values, should be a scalar or a flat array\n     * - `options` should be an object with the following information:\n     *   - `method` ('RK45'): ['RK23', 'RK45']\n     *   - `tol` (1e-3): Numeric tolerance of the method, the solver keeps the error estimates less than this value\n     *   - `firstStep`: Initial step size\n     *   - `minStep`: minimum step size of the method\n     *   - `maxStep`: maximum step size of the method\n     *   - `minDelta` (0.2): minimum ratio of change for the step\n     *   - `maxDelta` (5): maximum ratio of change for the step\n     *   - `maxIter` (1e4): maximum number of iterations\n     *\n     * The returned value is an object with `{t, y}` please note that even though `t` means time, it can represent any other independant variable like `x`:\n     * - `t` an array of size `[n]`\n     * - `y` the states array can be in two ways\n     *   - **if `y0` is a scalar:** returns an array-like of size `[n]`\n     *   - **if `y0` is a flat array-like of size [m]:** returns an array like of size `[n, m]`\n     *\n     * Syntax:\n     *\n     *     math.solveODE(func, tspan, y0)\n     *     math.solveODE(func, tspan, y0, options)\n     *\n     * Examples:\n     *\n     *     function func(t, y) {return y}\n     *     const tspan = [0, 4]\n     *     const y0 = 1\n     *     math.solveODE(func, tspan, y0)\n     *     math.solveODE(func, tspan, [1, 2])\n     *     math.solveODE(func, tspan, y0, { method:\"RK23\", maxStep:0.1 })\n     *\n     * See also:\n     *\n     *     derivative, simplifyCore\n     *\n     * @param {function} func The forcing function f(t,y)\n     * @param {Array | Matrix} tspan The time span\n     * @param {number | BigNumber | Unit | Array | Matrix} y0 The initial value\n     * @param {Object} [options] Optional configuration options\n     * @return {Object} Return an object with t and y values as arrays\n     */\n\n  function _rk(butcherTableau) {\n    // generates an adaptive runge kutta method from it's butcher tableau\n\n    return function (f, tspan, y0, options) {\n      // adaptive runge kutta methods\n      var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));\n      if (wrongTSpan) {\n        throw new Error('\"tspan\" must be an Array of two numeric values or two units [tStart, tEnd]');\n      }\n      var t0 = tspan[0]; // initial time\n      var tf = tspan[1]; // final time\n      var isForwards = larger(tf, t0);\n      var firstStep = options.firstStep;\n      if (firstStep !== undefined && !isPositive(firstStep)) {\n        throw new Error('\"firstStep\" must be positive');\n      }\n      var maxStep = options.maxStep;\n      if (maxStep !== undefined && !isPositive(maxStep)) {\n        throw new Error('\"maxStep\" must be positive');\n      }\n      var minStep = options.minStep;\n      if (minStep && isNegative(minStep)) {\n        throw new Error('\"minStep\" must be positive or zero');\n      }\n      var timeVars = [t0, tf, firstStep, minStep, maxStep].filter(x => x !== undefined);\n      if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {\n        throw new Error('Inconsistent type of \"t\" dependant variables');\n      }\n      var steps = 1; // divide time in this number of steps\n      var tol = options.tol ? options.tol : 1e-4; // define a tolerance (must be an option)\n      var minDelta = options.minDelta ? options.minDelta : 0.2;\n      var maxDelta = options.maxDelta ? options.maxDelta : 5;\n      var maxIter = options.maxIter ? options.maxIter : 10000; // stop inifite evaluation if something goes wrong\n      var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);\n      var [a, c, b, bp] = hasBigNumbers ? [bignumber(butcherTableau.a), bignumber(butcherTableau.c), bignumber(butcherTableau.b), bignumber(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];\n      var h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide(subtract(tf, t0), steps); // define the first step size\n      var t = [t0]; // start the time array\n      var y = [y0]; // start the solution array\n\n      var deltaB = subtract(b, bp); // b - bp\n\n      var n = 0;\n      var iter = 0;\n      var ongoing = _createOngoing(isForwards);\n      var trimStep = _createTrimStep(isForwards);\n      // iterate unitil it reaches either the final time or maximum iterations\n      while (ongoing(t[n], tf)) {\n        var k = [];\n\n        // trim the time step so that it doesn't overshoot\n        h = trimStep(t[n], tf, h);\n\n        // calculate the first value of k\n        k.push(f(t[n], y[n]));\n\n        // calculate the rest of the values of k\n        for (var i = 1; i < c.length; ++i) {\n          k.push(f(add(t[n], multiply(c[i], h)), add(y[n], multiply(h, a[i], k))));\n        }\n\n        // estimate the error by comparing solutions of different orders\n        var TE = max(abs(map(multiply(deltaB, k), X => isUnit(X) ? X.value : X)));\n        if (TE < tol && tol / TE > 1 / 4) {\n          // push solution if within tol\n          t.push(add(t[n], h));\n          y.push(add(y[n], multiply(h, b, k)));\n          n++;\n        }\n\n        // estimate the delta value that will affect the step size\n        var delta = 0.84 * (tol / TE) ** (1 / 5);\n        if (smaller(delta, minDelta)) {\n          delta = minDelta;\n        } else if (larger(delta, maxDelta)) {\n          delta = maxDelta;\n        }\n        delta = hasBigNumbers ? bignumber(delta) : delta;\n        h = multiply(h, delta);\n        if (maxStep && larger(abs(h), maxStep)) {\n          h = isForwards ? maxStep : unaryMinus(maxStep);\n        } else if (minStep && smaller(abs(h), minStep)) {\n          h = isForwards ? minStep : unaryMinus(minStep);\n        }\n        iter++;\n        if (iter > maxIter) {\n          throw new Error('Maximum number of iterations reached, try changing options');\n        }\n      }\n      return {\n        t,\n        y\n      };\n    };\n  }\n  function _rk23(f, tspan, y0, options) {\n    // Bogacki–Shampine method\n\n    // Define the butcher table\n    var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];\n    var c = [null, 1 / 2, 3 / 4, 1];\n    var b = [2 / 9, 1 / 3, 4 / 9, 0];\n    var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];\n    var butcherTableau = {\n      a,\n      c,\n      b,\n      bp\n    };\n\n    // Solve an adaptive step size rk method\n    return _rk(butcherTableau)(f, tspan, y0, options);\n  }\n  function _rk45(f, tspan, y0, options) {\n    // Dormand Prince method\n\n    // Define the butcher tableau\n    var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];\n    var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];\n    var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];\n    var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];\n    var butcherTableau = {\n      a,\n      c,\n      b,\n      bp\n    };\n\n    // Solve an adaptive step size rk method\n    return _rk(butcherTableau)(f, tspan, y0, options);\n  }\n  function _solveODE(f, tspan, y0, opt) {\n    var method = opt.method ? opt.method : 'RK45';\n    var methods = {\n      RK23: _rk23,\n      RK45: _rk45\n    };\n    if (method.toUpperCase() in methods) {\n      var methodOptions = _objectSpread({}, opt); // clone the options object\n      delete methodOptions.method; // delete the method as it won't be needed\n      return methods[method.toUpperCase()](f, tspan, y0, methodOptions);\n    } else {\n      // throw an error indicating there is no such method\n      var methodsWithQuotes = Object.keys(methods).map(x => \"\\\"\".concat(x, \"\\\"\"));\n      // generates a string of methods like: \"BDF\", \"RK23\" and \"RK45\"\n      var availableMethodsString = \"\".concat(methodsWithQuotes.slice(0, -1).join(', '), \" and \").concat(methodsWithQuotes.slice(-1));\n      throw new Error(\"Unavailable method \\\"\".concat(method, \"\\\". Available methods are \").concat(availableMethodsString));\n    }\n  }\n  function _createOngoing(isForwards) {\n    // returns the correct function to test if it's still iterating\n    return isForwards ? smaller : larger;\n  }\n  function _createTrimStep(isForwards) {\n    var outOfBounds = isForwards ? larger : smaller;\n    return function (t, tf, h) {\n      var next = add(t, h);\n      return outOfBounds(next, tf) ? subtract(tf, t) : h;\n    };\n  }\n  function isNumOrBig(x) {\n    // checks if it's a number or bignumber\n    return isBigNumber(x) || isNumber(x);\n  }\n  function _matrixSolveODE(f, T, y0, options) {\n    // receives matrices and returns matrices\n    var sol = _solveODE(f, T.toArray(), y0.toArray(), options);\n    return {\n      t: matrix(sol.t),\n      y: matrix(sol.y)\n    };\n  }\n  return typed('solveODE', {\n    'function, Array, Array, Object': _solveODE,\n    'function, Matrix, Matrix, Object': _matrixSolveODE,\n    'function, Array, Array': (f, T, y0) => _solveODE(f, T, y0, {}),\n    'function, Matrix, Matrix': (f, T, y0) => _matrixSolveODE(f, T, y0, {}),\n    'function, Array, number | BigNumber | Unit': (f, T, y0) => {\n      var sol = _solveODE(f, T, [y0], {});\n      return {\n        t: sol.t,\n        y: sol.y.map(Y => Y[0])\n      };\n    },\n    'function, Matrix, number | BigNumber | Unit': (f, T, y0) => {\n      var sol = _solveODE(f, T.toArray(), [y0], {});\n      return {\n        t: matrix(sol.t),\n        y: matrix(sol.y.map(Y => Y[0]))\n      };\n    },\n    'function, Array, number | BigNumber | Unit, Object': (f, T, y0, options) => {\n      var sol = _solveODE(f, T, [y0], options);\n      return {\n        t: sol.t,\n        y: sol.y.map(Y => Y[0])\n      };\n    },\n    'function, Matrix, number | BigNumber | Unit, Object': (f, T, y0, options) => {\n      var sol = _solveODE(f, T.toArray(), [y0], options);\n      return {\n        t: matrix(sol.t),\n        y: matrix(sol.y.map(Y => Y[0]))\n      };\n    }\n  });\n});","map":{"version":3,"names":["_defineProperty","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","isUnit","isNumber","isBigNumber","factory","name","dependencies","createSolveODE","_ref","typed","add","subtract","multiply","divide","max","map","abs","isPositive","isNegative","larger","smaller","matrix","bignumber","unaryMinus","_rk","butcherTableau","f","tspan","y0","options","wrongTSpan","every","isNumOrBig","Error","t0","tf","isForwards","firstStep","undefined","maxStep","minStep","timeVars","x","steps","tol","minDelta","maxDelta","maxIter","hasBigNumbers","some","a","c","b","bp","h","y","deltaB","n","iter","ongoing","_createOngoing","trimStep","_createTrimStep","k","i","TE","X","value","delta","_rk23","_rk45","_solveODE","opt","method","methods","RK23","RK45","toUpperCase","methodOptions","methodsWithQuotes","concat","availableMethodsString","slice","join","outOfBounds","next","_matrixSolveODE","T","sol","toArray","function, Array, Array","function, Matrix, Matrix","function, Array, number | BigNumber | Unit","Y","function, Matrix, number | BigNumber | Unit","function, Array, number | BigNumber | Unit, Object","function, Matrix, number | BigNumber | Unit, Object"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/function/numeric/solveODE.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { isUnit, isNumber, isBigNumber } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'solveODE';\nvar dependencies = ['typed', 'add', 'subtract', 'multiply', 'divide', 'max', 'map', 'abs', 'isPositive', 'isNegative', 'larger', 'smaller', 'matrix', 'bignumber', 'unaryMinus'];\nexport var createSolveODE = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    add,\n    subtract,\n    multiply,\n    divide,\n    max,\n    map,\n    abs,\n    isPositive,\n    isNegative,\n    larger,\n    smaller,\n    matrix,\n    bignumber,\n    unaryMinus\n  } = _ref;\n  /**\n     * Numerical Integration of Ordinary Differential Equations\n     *\n     * Two variable step methods are provided:\n     * - \"RK23\": Bogacki–Shampine method\n     * - \"RK45\": Dormand-Prince method RK5(4)7M (default)\n     *\n     * The arguments are expected as follows.\n     *\n     * - `func` should be the forcing function `f(t, y)`\n     * - `tspan` should be a vector of two numbers or units `[tStart, tEnd]`\n     * - `y0` the initial state values, should be a scalar or a flat array\n     * - `options` should be an object with the following information:\n     *   - `method` ('RK45'): ['RK23', 'RK45']\n     *   - `tol` (1e-3): Numeric tolerance of the method, the solver keeps the error estimates less than this value\n     *   - `firstStep`: Initial step size\n     *   - `minStep`: minimum step size of the method\n     *   - `maxStep`: maximum step size of the method\n     *   - `minDelta` (0.2): minimum ratio of change for the step\n     *   - `maxDelta` (5): maximum ratio of change for the step\n     *   - `maxIter` (1e4): maximum number of iterations\n     *\n     * The returned value is an object with `{t, y}` please note that even though `t` means time, it can represent any other independant variable like `x`:\n     * - `t` an array of size `[n]`\n     * - `y` the states array can be in two ways\n     *   - **if `y0` is a scalar:** returns an array-like of size `[n]`\n     *   - **if `y0` is a flat array-like of size [m]:** returns an array like of size `[n, m]`\n     *\n     * Syntax:\n     *\n     *     math.solveODE(func, tspan, y0)\n     *     math.solveODE(func, tspan, y0, options)\n     *\n     * Examples:\n     *\n     *     function func(t, y) {return y}\n     *     const tspan = [0, 4]\n     *     const y0 = 1\n     *     math.solveODE(func, tspan, y0)\n     *     math.solveODE(func, tspan, [1, 2])\n     *     math.solveODE(func, tspan, y0, { method:\"RK23\", maxStep:0.1 })\n     *\n     * See also:\n     *\n     *     derivative, simplifyCore\n     *\n     * @param {function} func The forcing function f(t,y)\n     * @param {Array | Matrix} tspan The time span\n     * @param {number | BigNumber | Unit | Array | Matrix} y0 The initial value\n     * @param {Object} [options] Optional configuration options\n     * @return {Object} Return an object with t and y values as arrays\n     */\n\n  function _rk(butcherTableau) {\n    // generates an adaptive runge kutta method from it's butcher tableau\n\n    return function (f, tspan, y0, options) {\n      // adaptive runge kutta methods\n      var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));\n      if (wrongTSpan) {\n        throw new Error('\"tspan\" must be an Array of two numeric values or two units [tStart, tEnd]');\n      }\n      var t0 = tspan[0]; // initial time\n      var tf = tspan[1]; // final time\n      var isForwards = larger(tf, t0);\n      var firstStep = options.firstStep;\n      if (firstStep !== undefined && !isPositive(firstStep)) {\n        throw new Error('\"firstStep\" must be positive');\n      }\n      var maxStep = options.maxStep;\n      if (maxStep !== undefined && !isPositive(maxStep)) {\n        throw new Error('\"maxStep\" must be positive');\n      }\n      var minStep = options.minStep;\n      if (minStep && isNegative(minStep)) {\n        throw new Error('\"minStep\" must be positive or zero');\n      }\n      var timeVars = [t0, tf, firstStep, minStep, maxStep].filter(x => x !== undefined);\n      if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {\n        throw new Error('Inconsistent type of \"t\" dependant variables');\n      }\n      var steps = 1; // divide time in this number of steps\n      var tol = options.tol ? options.tol : 1e-4; // define a tolerance (must be an option)\n      var minDelta = options.minDelta ? options.minDelta : 0.2;\n      var maxDelta = options.maxDelta ? options.maxDelta : 5;\n      var maxIter = options.maxIter ? options.maxIter : 10000; // stop inifite evaluation if something goes wrong\n      var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);\n      var [a, c, b, bp] = hasBigNumbers ? [bignumber(butcherTableau.a), bignumber(butcherTableau.c), bignumber(butcherTableau.b), bignumber(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];\n      var h = firstStep ? isForwards ? firstStep : unaryMinus(firstStep) : divide(subtract(tf, t0), steps); // define the first step size\n      var t = [t0]; // start the time array\n      var y = [y0]; // start the solution array\n\n      var deltaB = subtract(b, bp); // b - bp\n\n      var n = 0;\n      var iter = 0;\n      var ongoing = _createOngoing(isForwards);\n      var trimStep = _createTrimStep(isForwards);\n      // iterate unitil it reaches either the final time or maximum iterations\n      while (ongoing(t[n], tf)) {\n        var k = [];\n\n        // trim the time step so that it doesn't overshoot\n        h = trimStep(t[n], tf, h);\n\n        // calculate the first value of k\n        k.push(f(t[n], y[n]));\n\n        // calculate the rest of the values of k\n        for (var i = 1; i < c.length; ++i) {\n          k.push(f(add(t[n], multiply(c[i], h)), add(y[n], multiply(h, a[i], k))));\n        }\n\n        // estimate the error by comparing solutions of different orders\n        var TE = max(abs(map(multiply(deltaB, k), X => isUnit(X) ? X.value : X)));\n        if (TE < tol && tol / TE > 1 / 4) {\n          // push solution if within tol\n          t.push(add(t[n], h));\n          y.push(add(y[n], multiply(h, b, k)));\n          n++;\n        }\n\n        // estimate the delta value that will affect the step size\n        var delta = 0.84 * (tol / TE) ** (1 / 5);\n        if (smaller(delta, minDelta)) {\n          delta = minDelta;\n        } else if (larger(delta, maxDelta)) {\n          delta = maxDelta;\n        }\n        delta = hasBigNumbers ? bignumber(delta) : delta;\n        h = multiply(h, delta);\n        if (maxStep && larger(abs(h), maxStep)) {\n          h = isForwards ? maxStep : unaryMinus(maxStep);\n        } else if (minStep && smaller(abs(h), minStep)) {\n          h = isForwards ? minStep : unaryMinus(minStep);\n        }\n        iter++;\n        if (iter > maxIter) {\n          throw new Error('Maximum number of iterations reached, try changing options');\n        }\n      }\n      return {\n        t,\n        y\n      };\n    };\n  }\n  function _rk23(f, tspan, y0, options) {\n    // Bogacki–Shampine method\n\n    // Define the butcher table\n    var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];\n    var c = [null, 1 / 2, 3 / 4, 1];\n    var b = [2 / 9, 1 / 3, 4 / 9, 0];\n    var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];\n    var butcherTableau = {\n      a,\n      c,\n      b,\n      bp\n    };\n\n    // Solve an adaptive step size rk method\n    return _rk(butcherTableau)(f, tspan, y0, options);\n  }\n  function _rk45(f, tspan, y0, options) {\n    // Dormand Prince method\n\n    // Define the butcher tableau\n    var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];\n    var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];\n    var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];\n    var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];\n    var butcherTableau = {\n      a,\n      c,\n      b,\n      bp\n    };\n\n    // Solve an adaptive step size rk method\n    return _rk(butcherTableau)(f, tspan, y0, options);\n  }\n  function _solveODE(f, tspan, y0, opt) {\n    var method = opt.method ? opt.method : 'RK45';\n    var methods = {\n      RK23: _rk23,\n      RK45: _rk45\n    };\n    if (method.toUpperCase() in methods) {\n      var methodOptions = _objectSpread({}, opt); // clone the options object\n      delete methodOptions.method; // delete the method as it won't be needed\n      return methods[method.toUpperCase()](f, tspan, y0, methodOptions);\n    } else {\n      // throw an error indicating there is no such method\n      var methodsWithQuotes = Object.keys(methods).map(x => \"\\\"\".concat(x, \"\\\"\"));\n      // generates a string of methods like: \"BDF\", \"RK23\" and \"RK45\"\n      var availableMethodsString = \"\".concat(methodsWithQuotes.slice(0, -1).join(', '), \" and \").concat(methodsWithQuotes.slice(-1));\n      throw new Error(\"Unavailable method \\\"\".concat(method, \"\\\". Available methods are \").concat(availableMethodsString));\n    }\n  }\n  function _createOngoing(isForwards) {\n    // returns the correct function to test if it's still iterating\n    return isForwards ? smaller : larger;\n  }\n  function _createTrimStep(isForwards) {\n    var outOfBounds = isForwards ? larger : smaller;\n    return function (t, tf, h) {\n      var next = add(t, h);\n      return outOfBounds(next, tf) ? subtract(tf, t) : h;\n    };\n  }\n  function isNumOrBig(x) {\n    // checks if it's a number or bignumber\n    return isBigNumber(x) || isNumber(x);\n  }\n  function _matrixSolveODE(f, T, y0, options) {\n    // receives matrices and returns matrices\n    var sol = _solveODE(f, T.toArray(), y0.toArray(), options);\n    return {\n      t: matrix(sol.t),\n      y: matrix(sol.y)\n    };\n  }\n  return typed('solveODE', {\n    'function, Array, Array, Object': _solveODE,\n    'function, Matrix, Matrix, Object': _matrixSolveODE,\n    'function, Array, Array': (f, T, y0) => _solveODE(f, T, y0, {}),\n    'function, Matrix, Matrix': (f, T, y0) => _matrixSolveODE(f, T, y0, {}),\n    'function, Array, number | BigNumber | Unit': (f, T, y0) => {\n      var sol = _solveODE(f, T, [y0], {});\n      return {\n        t: sol.t,\n        y: sol.y.map(Y => Y[0])\n      };\n    },\n    'function, Matrix, number | BigNumber | Unit': (f, T, y0) => {\n      var sol = _solveODE(f, T.toArray(), [y0], {});\n      return {\n        t: matrix(sol.t),\n        y: matrix(sol.y.map(Y => Y[0]))\n      };\n    },\n    'function, Array, number | BigNumber | Unit, Object': (f, T, y0, options) => {\n      var sol = _solveODE(f, T, [y0], options);\n      return {\n        t: sol.t,\n        y: sol.y.map(Y => Y[0])\n      };\n    },\n    'function, Matrix, number | BigNumber | Unit, Object': (f, T, y0, options) => {\n      var sol = _solveODE(f, T.toArray(), [y0], options);\n      return {\n        t: matrix(sol.t),\n        y: matrix(sol.y.map(Y => Y[0]))\n      };\n    }\n  });\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}