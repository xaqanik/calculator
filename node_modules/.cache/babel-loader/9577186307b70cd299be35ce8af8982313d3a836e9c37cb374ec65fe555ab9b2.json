{"ast":null,"code":"import { createFilter } from '../../function/matrix/filter.js';\nimport { factory } from '../../utils/factory.js';\nimport { isFunctionAssignmentNode, isSymbolNode } from '../../utils/is.js';\nimport { compileInlineExpression } from './utils/compileInlineExpression.js';\nimport { createTransformCallback } from './utils/transformCallback.js';\nvar name = 'filter';\nvar dependencies = ['typed'];\nexport var createFilterTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Attach a transform function to math.filter\n   * Adds a property transform containing the transform function.\n   *\n   * This transform adds support for equations as test function for math.filter,\n   * so you can do something like 'filter([3, -2, 5], x > 0)'.\n   */\n  function filterTransform(args, math, scope) {\n    var filter = createFilter({\n      typed\n    });\n    var transformCallback = createTransformCallback({\n      typed\n    });\n    if (args.length === 0) {\n      return filter();\n    }\n    var x = args[0];\n    if (args.length === 1) {\n      return filter(x);\n    }\n    var N = args.length - 1;\n    var callback = args[N];\n    if (x) {\n      x = _compileAndEvaluate(x, scope);\n    }\n    if (callback) {\n      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = _compileAndEvaluate(callback, scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(callback, math, scope);\n      }\n    }\n    return filter(x, transformCallback(callback, N));\n  }\n  filterTransform.rawArgs = true;\n  function _compileAndEvaluate(arg, scope) {\n    return arg.compile().evaluate(scope);\n  }\n  return filterTransform;\n}, {\n  isTransformFunction: true\n});","map":{"version":3,"names":["createFilter","factory","isFunctionAssignmentNode","isSymbolNode","compileInlineExpression","createTransformCallback","name","dependencies","createFilterTransform","_ref","typed","filterTransform","args","math","scope","filter","transformCallback","length","x","N","callback","_compileAndEvaluate","rawArgs","arg","compile","evaluate","isTransformFunction"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/expression/transform/filter.transform.js"],"sourcesContent":["import { createFilter } from '../../function/matrix/filter.js';\nimport { factory } from '../../utils/factory.js';\nimport { isFunctionAssignmentNode, isSymbolNode } from '../../utils/is.js';\nimport { compileInlineExpression } from './utils/compileInlineExpression.js';\nimport { createTransformCallback } from './utils/transformCallback.js';\nvar name = 'filter';\nvar dependencies = ['typed'];\nexport var createFilterTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Attach a transform function to math.filter\n   * Adds a property transform containing the transform function.\n   *\n   * This transform adds support for equations as test function for math.filter,\n   * so you can do something like 'filter([3, -2, 5], x > 0)'.\n   */\n  function filterTransform(args, math, scope) {\n    var filter = createFilter({\n      typed\n    });\n    var transformCallback = createTransformCallback({\n      typed\n    });\n    if (args.length === 0) {\n      return filter();\n    }\n    var x = args[0];\n    if (args.length === 1) {\n      return filter(x);\n    }\n    var N = args.length - 1;\n    var callback = args[N];\n    if (x) {\n      x = _compileAndEvaluate(x, scope);\n    }\n    if (callback) {\n      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = _compileAndEvaluate(callback, scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(callback, math, scope);\n      }\n    }\n    return filter(x, transformCallback(callback, N));\n  }\n  filterTransform.rawArgs = true;\n  function _compileAndEvaluate(arg, scope) {\n    return arg.compile().evaluate(scope);\n  }\n  return filterTransform;\n}, {\n  isTransformFunction: true\n});"],"mappings":"AAAA,SAASA,YAAY,QAAQ,iCAAiC;AAC9D,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,wBAAwB,EAAEC,YAAY,QAAQ,mBAAmB;AAC1E,SAASC,uBAAuB,QAAQ,oCAAoC;AAC5E,SAASC,uBAAuB,QAAQ,8BAA8B;AACtE,IAAIC,IAAI,GAAG,QAAQ;AACnB,IAAIC,YAAY,GAAG,CAAC,OAAO,CAAC;AAC5B,OAAO,IAAIC,qBAAqB,GAAG,eAAeP,OAAO,CAACK,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EACpF,IAAI;IACFC;EACF,CAAC,GAAGD,IAAI;EACR;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASE,eAAeA,CAACC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;IAC1C,IAAIC,MAAM,GAAGf,YAAY,CAAC;MACxBU;IACF,CAAC,CAAC;IACF,IAAIM,iBAAiB,GAAGX,uBAAuB,CAAC;MAC9CK;IACF,CAAC,CAAC;IACF,IAAIE,IAAI,CAACK,MAAM,KAAK,CAAC,EAAE;MACrB,OAAOF,MAAM,CAAC,CAAC;IACjB;IACA,IAAIG,CAAC,GAAGN,IAAI,CAAC,CAAC,CAAC;IACf,IAAIA,IAAI,CAACK,MAAM,KAAK,CAAC,EAAE;MACrB,OAAOF,MAAM,CAACG,CAAC,CAAC;IAClB;IACA,IAAIC,CAAC,GAAGP,IAAI,CAACK,MAAM,GAAG,CAAC;IACvB,IAAIG,QAAQ,GAAGR,IAAI,CAACO,CAAC,CAAC;IACtB,IAAID,CAAC,EAAE;MACLA,CAAC,GAAGG,mBAAmB,CAACH,CAAC,EAAEJ,KAAK,CAAC;IACnC;IACA,IAAIM,QAAQ,EAAE;MACZ,IAAIjB,YAAY,CAACiB,QAAQ,CAAC,IAAIlB,wBAAwB,CAACkB,QAAQ,CAAC,EAAE;QAChE;QACAA,QAAQ,GAAGC,mBAAmB,CAACD,QAAQ,EAAEN,KAAK,CAAC;MACjD,CAAC,MAAM;QACL;QACAM,QAAQ,GAAGhB,uBAAuB,CAACgB,QAAQ,EAAEP,IAAI,EAAEC,KAAK,CAAC;MAC3D;IACF;IACA,OAAOC,MAAM,CAACG,CAAC,EAAEF,iBAAiB,CAACI,QAAQ,EAAED,CAAC,CAAC,CAAC;EAClD;EACAR,eAAe,CAACW,OAAO,GAAG,IAAI;EAC9B,SAASD,mBAAmBA,CAACE,GAAG,EAAET,KAAK,EAAE;IACvC,OAAOS,GAAG,CAACC,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACX,KAAK,CAAC;EACtC;EACA,OAAOH,eAAe;AACxB,CAAC,EAAE;EACDe,mBAAmB,EAAE;AACvB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}