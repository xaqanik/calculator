{"ast":null,"code":"'use strict';\n\n/**\n *\n * This class offers the possibility to calculate fractions.\n * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.\n *\n * Array/Object form\n * [ 0 => <numerator>, 1 => <denominator> ]\n * { n => <numerator>, d => <denominator> }\n *\n * Integer form\n * - Single integer value as BigInt or Number\n *\n * Double form\n * - Single double value as Number\n *\n * String form\n * 123.456 - a simple double\n * 123/456 - a string fraction\n * 123.'456' - a double with repeating decimal places\n * 123.(456) - synonym\n * 123.45'6' - a double with repeating last place\n * 123.45(6) - synonym\n *\n * Example:\n * let f = new Fraction(\"9.4'31'\");\n * f.mul([-4, 3]).div(4.9);\n *\n */\n\n// Set Identity function to downgrade BigInt to Number if needed\nif (typeof BigInt === 'undefined') BigInt = function (n) {\n  if (isNaN(n)) throw new Error(\"\");\n  return n;\n};\nconst C_ZERO = BigInt(0);\nconst C_ONE = BigInt(1);\nconst C_TWO = BigInt(2);\nconst C_THREE = BigInt(3);\nconst C_FIVE = BigInt(5);\nconst C_TEN = BigInt(10);\nconst MAX_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\n\n// Maximum search depth for cyclic rational numbers. 2000 should be more than enough.\n// Example: 1/7 = 0.(142857) has 6 repeating decimal places.\n// If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits\nconst MAX_CYCLE_LEN = 2000;\n\n// Parsed data to avoid calling \"new\" all the time\nconst P = {\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE\n};\nfunction assign(n, s) {\n  try {\n    n = BigInt(n);\n  } catch (e) {\n    throw InvalidParameter();\n  }\n  return n * s;\n}\nfunction ifloor(x) {\n  return typeof x === 'bigint' ? x : Math.floor(x);\n}\n\n// Creates a new Fraction internally without the need of the bulky constructor\nfunction newFraction(n, d) {\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n  const f = Object.create(Fraction.prototype);\n  f[\"s\"] = n < C_ZERO ? -C_ONE : C_ONE;\n  n = n < C_ZERO ? -n : n;\n  const a = gcd(n, d);\n  f[\"n\"] = n / a;\n  f[\"d\"] = d / a;\n  return f;\n}\nconst FACTORSTEPS = [C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO * C_THREE, C_TWO, C_TWO * C_THREE]; // repeats\nfunction factorize(n) {\n  const factors = Object.create(null);\n  if (n <= C_ONE) {\n    factors[n] = C_ONE;\n    return factors;\n  }\n  const add = p => {\n    factors[p] = (factors[p] || C_ZERO) + C_ONE;\n  };\n  while (n % C_TWO === C_ZERO) {\n    add(C_TWO);\n    n /= C_TWO;\n  }\n  while (n % C_THREE === C_ZERO) {\n    add(C_THREE);\n    n /= C_THREE;\n  }\n  while (n % C_FIVE === C_ZERO) {\n    add(C_FIVE);\n    n /= C_FIVE;\n  }\n\n  // 30-wheel trial division: test only residues coprime to 2*3*5\n  // Residue step pattern after 5: 7,11,13,17,19,23,29,31, ...\n  for (let si = 0, p = C_TWO + C_FIVE; p * p <= n;) {\n    while (n % p === C_ZERO) {\n      add(p);\n      n /= p;\n    }\n    p += FACTORSTEPS[si];\n    si = si + 1 & 7; // fast modulo 8\n  }\n  if (n > C_ONE) add(n);\n  return factors;\n}\nconst parse = function (p1, p2) {\n  let n = C_ZERO,\n    d = C_ONE,\n    s = C_ONE;\n  if (p1 === undefined || p1 === null) {// No argument\n    /* void */\n  } else if (p2 !== undefined) {\n    // Two arguments\n\n    if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else if (isNaN(p1)) {\n      throw InvalidParameter();\n    } else if (p1 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      n = BigInt(p1);\n    }\n    if (typeof p2 === \"bigint\") {\n      d = p2;\n    } else if (isNaN(p2)) {\n      throw InvalidParameter();\n    } else if (p2 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      d = BigInt(p2);\n    }\n    s = n * d;\n  } else if (typeof p1 === \"object\") {\n    if (\"d\" in p1 && \"n\" in p1) {\n      n = BigInt(p1[\"n\"]);\n      d = BigInt(p1[\"d\"]);\n      if (\"s\" in p1) n *= BigInt(p1[\"s\"]);\n    } else if (0 in p1) {\n      n = BigInt(p1[0]);\n      if (1 in p1) d = BigInt(p1[1]);\n    } else if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else {\n      throw InvalidParameter();\n    }\n    s = n * d;\n  } else if (typeof p1 === \"number\") {\n    if (isNaN(p1)) {\n      throw InvalidParameter();\n    }\n    if (p1 < 0) {\n      s = -C_ONE;\n      p1 = -p1;\n    }\n    if (p1 % 1 === 0) {\n      n = BigInt(p1);\n    } else {\n      let z = 1;\n      let A = 0,\n        B = 1;\n      let C = 1,\n        D = 1;\n      let N = 10000000;\n      if (p1 >= 1) {\n        z = 10 ** Math.floor(1 + Math.log10(p1));\n        p1 /= z;\n      }\n\n      // Using Farey Sequences\n\n      while (B <= N && D <= N) {\n        let M = (A + C) / (B + D);\n        if (p1 === M) {\n          if (B + D <= N) {\n            n = A + C;\n            d = B + D;\n          } else if (D > B) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n          break;\n        } else {\n          if (p1 > M) {\n            A += C;\n            B += D;\n          } else {\n            C += A;\n            D += B;\n          }\n          if (B > N) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n        }\n      }\n      n = BigInt(n) * BigInt(z);\n      d = BigInt(d);\n    }\n  } else if (typeof p1 === \"string\") {\n    let ndx = 0;\n    let v = C_ZERO,\n      w = C_ZERO,\n      x = C_ZERO,\n      y = C_ONE,\n      z = C_ONE;\n    let match = p1.replace(/_/g, '').match(/\\d+|./g);\n    if (match === null) throw InvalidParameter();\n    if (match[ndx] === '-') {\n      // Check for minus sign at the beginning\n      s = -C_ONE;\n      ndx++;\n    } else if (match[ndx] === '+') {\n      // Check for plus sign at the beginning\n      ndx++;\n    }\n    if (match.length === ndx + 1) {\n      // Check if it's just a simple number \"1234\"\n      w = assign(match[ndx++], s);\n    } else if (match[ndx + 1] === '.' || match[ndx] === '.') {\n      // Check if it's a decimal number\n\n      if (match[ndx] !== '.') {\n        // Handle 0.5 and .5\n        v = assign(match[ndx++], s);\n      }\n      ndx++;\n\n      // Check for decimal places\n      if (ndx + 1 === match.length || match[ndx + 1] === '(' && match[ndx + 3] === ')' || match[ndx + 1] === \"'\" && match[ndx + 3] === \"'\") {\n        w = assign(match[ndx], s);\n        y = C_TEN ** BigInt(match[ndx].length);\n        ndx++;\n      }\n\n      // Check for repeating places\n      if (match[ndx] === '(' && match[ndx + 2] === ')' || match[ndx] === \"'\" && match[ndx + 2] === \"'\") {\n        x = assign(match[ndx + 1], s);\n        z = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;\n        ndx += 3;\n      }\n    } else if (match[ndx + 1] === '/' || match[ndx + 1] === ':') {\n      // Check for a simple fraction \"123/456\" or \"123:456\"\n      w = assign(match[ndx], s);\n      y = assign(match[ndx + 2], C_ONE);\n      ndx += 3;\n    } else if (match[ndx + 3] === '/' && match[ndx + 1] === ' ') {\n      // Check for a complex fraction \"123 1/2\"\n      v = assign(match[ndx], s);\n      w = assign(match[ndx + 2], s);\n      y = assign(match[ndx + 4], C_ONE);\n      ndx += 5;\n    }\n    if (match.length <= ndx) {\n      // Check for more tokens on the stack\n      d = y * z;\n      s = /* void */\n      n = x + d * v + z * w;\n    } else {\n      throw InvalidParameter();\n    }\n  } else if (typeof p1 === \"bigint\") {\n    n = p1;\n    s = p1;\n    d = C_ONE;\n  } else {\n    throw InvalidParameter();\n  }\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n  P[\"s\"] = s < C_ZERO ? -C_ONE : C_ONE;\n  P[\"n\"] = n < C_ZERO ? -n : n;\n  P[\"d\"] = d < C_ZERO ? -d : d;\n};\nfunction modpow(b, e, m) {\n  let r = C_ONE;\n  for (; e > C_ZERO; b = b * b % m, e >>= C_ONE) {\n    if (e & C_ONE) {\n      r = r * b % m;\n    }\n  }\n  return r;\n}\nfunction cycleLen(n, d) {\n  for (; d % C_TWO === C_ZERO; d /= C_TWO) {}\n  for (; d % C_FIVE === C_ZERO; d /= C_FIVE) {}\n  if (d === C_ONE)\n    // Catch non-cyclic numbers\n    return C_ZERO;\n\n  // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:\n  // 10^(d-1) % d == 1\n  // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,\n  // as we want to translate the numbers to strings.\n\n  let rem = C_TEN % d;\n  let t = 1;\n  for (; rem !== C_ONE; t++) {\n    rem = rem * C_TEN % d;\n    if (t > MAX_CYCLE_LEN) return C_ZERO; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`\n  }\n  return BigInt(t);\n}\nfunction cycleStart(n, d, len) {\n  let rem1 = C_ONE;\n  let rem2 = modpow(C_TEN, len, d);\n  for (let t = 0; t < 300; t++) {\n    // s < ~log10(Number.MAX_VALUE)\n    // Solve 10^s == 10^(s+t) (mod d)\n\n    if (rem1 === rem2) return BigInt(t);\n    rem1 = rem1 * C_TEN % d;\n    rem2 = rem2 * C_TEN % d;\n  }\n  return 0;\n}\nfunction gcd(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n  while (1) {\n    a %= b;\n    if (!a) return b;\n    b %= a;\n    if (!b) return a;\n  }\n}\n\n/**\n * Module constructor\n *\n * @constructor\n * @param {number|Fraction=} a\n * @param {number=} b\n */\nfunction Fraction(a, b) {\n  parse(a, b);\n  if (this instanceof Fraction) {\n    a = gcd(P[\"d\"], P[\"n\"]); // Abuse a\n    this[\"s\"] = P[\"s\"];\n    this[\"n\"] = P[\"n\"] / a;\n    this[\"d\"] = P[\"d\"] / a;\n  } else {\n    return newFraction(P['s'] * P['n'], P['d']);\n  }\n}\nconst DivisionByZero = function () {\n  return new Error(\"Division by Zero\");\n};\nconst InvalidParameter = function () {\n  return new Error(\"Invalid argument\");\n};\nconst NonIntegerParameter = function () {\n  return new Error(\"Parameters must be integer\");\n};\nFraction.prototype = {\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE,\n  /**\n   * Calculates the absolute value\n   *\n   * Ex: new Fraction(-4).abs() => 4\n   **/\n  \"abs\": function () {\n    return newFraction(this[\"n\"], this[\"d\"]);\n  },\n  /**\n   * Inverts the sign of the current fraction\n   *\n   * Ex: new Fraction(-4).neg() => 4\n   **/\n  \"neg\": function () {\n    return newFraction(-this[\"s\"] * this[\"n\"], this[\"d\"]);\n  },\n  /**\n   * Adds two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => 467 / 30\n   **/\n  \"add\": function (a, b) {\n    parse(a, b);\n    return newFraction(this[\"s\"] * this[\"n\"] * P[\"d\"] + P[\"s\"] * this[\"d\"] * P[\"n\"], this[\"d\"] * P[\"d\"]);\n  },\n  /**\n   * Subtracts two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => -427 / 30\n   **/\n  \"sub\": function (a, b) {\n    parse(a, b);\n    return newFraction(this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * this[\"d\"] * P[\"n\"], this[\"d\"] * P[\"d\"]);\n  },\n  /**\n   * Multiplies two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").mul(3) => 5776 / 111\n   **/\n  \"mul\": function (a, b) {\n    parse(a, b);\n    return newFraction(this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"n\"], this[\"d\"] * P[\"d\"]);\n  },\n  /**\n   * Divides two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").inverse().div(3)\n   **/\n  \"div\": function (a, b) {\n    parse(a, b);\n    return newFraction(this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"d\"], this[\"d\"] * P[\"n\"]);\n  },\n  /**\n   * Clones the actual object\n   *\n   * Ex: new Fraction(\"-17.(345)\").clone()\n   **/\n  \"clone\": function () {\n    return newFraction(this['s'] * this['n'], this['d']);\n  },\n  /**\n   * Calculates the modulo of two rational numbers - a more precise fmod\n   *\n   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)\n   * Ex: new Fraction(20, 10).mod().equals(0) ? \"is Integer\"\n   **/\n  \"mod\": function (a, b) {\n    if (a === undefined) {\n      return newFraction(this[\"s\"] * this[\"n\"] % this[\"d\"], C_ONE);\n    }\n    parse(a, b);\n    if (C_ZERO === P[\"n\"] * this[\"d\"]) {\n      throw DivisionByZero();\n    }\n\n    /**\n     * I derived the rational modulo similar to the modulo for integers\n     *\n     * https://raw.org/book/analysis/rational-numbers/\n     *\n     *    n1/d1 = (n2/d2) * q + r, where 0 ≤ r < n2/d2\n     * => d2 * n1 = n2 * d1 * q + d1 * d2 * r\n     * => r = (d2 * n1 - n2 * d1 * q) / (d1 * d2)\n     *      = (d2 * n1 - n2 * d1 * floor((d2 * n1) / (n2 * d1))) / (d1 * d2)\n     *      = ((d2 * n1) % (n2 * d1)) / (d1 * d2)\n     */\n    return newFraction(this[\"s\"] * (P[\"d\"] * this[\"n\"]) % (P[\"n\"] * this[\"d\"]), P[\"d\"] * this[\"d\"]);\n  },\n  /**\n   * Calculates the fractional gcd of two rational numbers\n   *\n   * Ex: new Fraction(5,8).gcd(3,7) => 1/56\n   */\n  \"gcd\": function (a, b) {\n    parse(a, b);\n\n    // https://raw.org/book/analysis/rational-numbers/\n    // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)\n\n    return newFraction(gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]), P[\"d\"] * this[\"d\"]);\n  },\n  /**\n   * Calculates the fractional lcm of two rational numbers\n   *\n   * Ex: new Fraction(5,8).lcm(3,7) => 15\n   */\n  \"lcm\": function (a, b) {\n    parse(a, b);\n\n    // https://raw.org/book/analysis/rational-numbers/\n    // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)\n\n    if (P[\"n\"] === C_ZERO && this[\"n\"] === C_ZERO) {\n      return newFraction(C_ZERO, C_ONE);\n    }\n    return newFraction(P[\"n\"] * this[\"n\"], gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]));\n  },\n  /**\n   * Gets the inverse of the fraction, means numerator and denominator are exchanged\n   *\n   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3\n   **/\n  \"inverse\": function () {\n    return newFraction(this[\"s\"] * this[\"d\"], this[\"n\"]);\n  },\n  /**\n   * Calculates the fraction to some integer exponent\n   *\n   * Ex: new Fraction(-1,2).pow(-3) => -8\n   */\n  \"pow\": function (a, b) {\n    parse(a, b);\n\n    // Trivial case when exp is an integer\n\n    if (P['d'] === C_ONE) {\n      if (P['s'] < C_ZERO) {\n        return newFraction((this['s'] * this[\"d\"]) ** P['n'], this[\"n\"] ** P['n']);\n      } else {\n        return newFraction((this['s'] * this[\"n\"]) ** P['n'], this[\"d\"] ** P['n']);\n      }\n    }\n\n    // Negative roots become complex\n    //     (-a/b)^(c/d) = x\n    // ⇔ (-1)^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula\n    // From which follows that only for c=0 the root is non-complex\n    if (this['s'] < C_ZERO) return null;\n\n    // Now prime factor n and d\n    let N = factorize(this['n']);\n    let D = factorize(this['d']);\n\n    // Exponentiate and take root for n and d individually\n    let n = C_ONE;\n    let d = C_ONE;\n    for (let k in N) {\n      if (k === '1') continue;\n      if (k === '0') {\n        n = C_ZERO;\n        break;\n      }\n      N[k] *= P['n'];\n      if (N[k] % P['d'] === C_ZERO) {\n        N[k] /= P['d'];\n      } else return null;\n      n *= BigInt(k) ** N[k];\n    }\n    for (let k in D) {\n      if (k === '1') continue;\n      D[k] *= P['n'];\n      if (D[k] % P['d'] === C_ZERO) {\n        D[k] /= P['d'];\n      } else return null;\n      d *= BigInt(k) ** D[k];\n    }\n    if (P['s'] < C_ZERO) {\n      return newFraction(d, n);\n    }\n    return newFraction(n, d);\n  },\n  /**\n   * Calculates the logarithm of a fraction to a given rational base\n   *\n   * Ex: new Fraction(27, 8).log(9, 4) => 3/2\n   */\n  \"log\": function (a, b) {\n    parse(a, b);\n    if (this['s'] <= C_ZERO || P['s'] <= C_ZERO) return null;\n    const allPrimes = Object.create(null);\n    const baseFactors = factorize(P['n']);\n    const T1 = factorize(P['d']);\n    const numberFactors = factorize(this['n']);\n    const T2 = factorize(this['d']);\n    for (const prime in T1) {\n      baseFactors[prime] = (baseFactors[prime] || C_ZERO) - T1[prime];\n    }\n    for (const prime in T2) {\n      numberFactors[prime] = (numberFactors[prime] || C_ZERO) - T2[prime];\n    }\n    for (const prime in baseFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n    for (const prime in numberFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n    let retN = null;\n    let retD = null;\n\n    // Iterate over all unique primes to determine if a consistent ratio exists\n    for (const prime in allPrimes) {\n      const baseExponent = baseFactors[prime] || C_ZERO;\n      const numberExponent = numberFactors[prime] || C_ZERO;\n      if (baseExponent === C_ZERO) {\n        if (numberExponent !== C_ZERO) {\n          return null; // Logarithm cannot be expressed as a rational number\n        }\n        continue; // Skip this prime since both exponents are zero\n      }\n\n      // Calculate the ratio of exponents for this prime\n      let curN = numberExponent;\n      let curD = baseExponent;\n\n      // Simplify the current ratio\n      const gcdValue = gcd(curN, curD);\n      curN /= gcdValue;\n      curD /= gcdValue;\n\n      // Check if this is the first ratio; otherwise, ensure ratios are consistent\n      if (retN === null && retD === null) {\n        retN = curN;\n        retD = curD;\n      } else if (curN * retD !== retN * curD) {\n        return null; // Ratios do not match, logarithm cannot be rational\n      }\n    }\n    return retN !== null && retD !== null ? newFraction(retN, retD) : null;\n  },\n  /**\n   * Check if two rational numbers are the same\n   *\n   * Ex: new Fraction(19.6).equals([98, 5]);\n   **/\n  \"equals\": function (a, b) {\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] === P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n  /**\n   * Check if this rational number is less than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lt\": function (a, b) {\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] < P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n  /**\n   * Check if this rational number is less than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lte\": function (a, b) {\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] <= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n  /**\n   * Check if this rational number is greater than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gt\": function (a, b) {\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] > P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n  /**\n   * Check if this rational number is greater than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gte\": function (a, b) {\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] >= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n  /**\n   * Compare two rational numbers\n   * < 0 iff this < that\n   * > 0 iff this > that\n   * = 0 iff this = that\n   *\n   * Ex: new Fraction(19.6).compare([98, 5]);\n   **/\n  \"compare\": function (a, b) {\n    parse(a, b);\n    let t = this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * P[\"n\"] * this[\"d\"];\n    return (C_ZERO < t) - (t < C_ZERO);\n  },\n  /**\n   * Calculates the ceil of a rational number\n   *\n   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)\n   **/\n  \"ceil\": function (places) {\n    places = C_TEN ** BigInt(places || 0);\n    return newFraction(ifloor(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) + (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO), places);\n  },\n  /**\n   * Calculates the floor of a rational number\n   *\n   * Ex: new Fraction('4.(3)').floor() => (4 / 1)\n   **/\n  \"floor\": function (places) {\n    places = C_TEN ** BigInt(places || 0);\n    return newFraction(ifloor(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) - (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] < C_ZERO ? C_ONE : C_ZERO), places);\n  },\n  /**\n   * Rounds a rational numbers\n   *\n   * Ex: new Fraction('4.(3)').round() => (4 / 1)\n   **/\n  \"round\": function (places) {\n    places = C_TEN ** BigInt(places || 0);\n\n    /* Derivation:\n     s >= 0:\n      round(n / d) = ifloor(n / d) + (n % d) / d >= 0.5 ? 1 : 0\n                   = ifloor(n / d) + 2(n % d) >= d ? 1 : 0\n    s < 0:\n      round(n / d) =-ifloor(n / d) - (n % d) / d > 0.5 ? 1 : 0\n                   =-ifloor(n / d) - 2(n % d) > d ? 1 : 0\n     =>:\n     round(s * n / d) = s * ifloor(n / d) + s * (C + 2(n % d) > d ? 1 : 0)\n        where C = s >= 0 ? 1 : 0, to fix the >= for the positve case.\n    */\n\n    return newFraction(ifloor(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) + this[\"s\"] * ((this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this[\"n\"] % this[\"d\"]) > this[\"d\"] ? C_ONE : C_ZERO), places);\n  },\n  /**\n    * Rounds a rational number to a multiple of another rational number\n    *\n    * Ex: new Fraction('0.9').roundTo(\"1/8\") => 7 / 8\n    **/\n  \"roundTo\": function (a, b) {\n    /*\n    k * x/y ≤ a/b < (k+1) * x/y\n    ⇔ k ≤ a/b / (x/y) < (k+1)\n    ⇔ k = floor(a/b * y/x)\n    ⇔ k = floor((a * y) / (b * x))\n    */\n\n    parse(a, b);\n    const n = this['n'] * P['d'];\n    const d = this['d'] * P['n'];\n    const r = n % d;\n\n    // round(n / d) = ifloor(n / d) + 2(n % d) >= d ? 1 : 0\n    let k = ifloor(n / d);\n    if (r + r >= d) {\n      k++;\n    }\n    return newFraction(this['s'] * k * P['n'], P['d']);\n  },\n  /**\n   * Check if two rational numbers are divisible\n   *\n   * Ex: new Fraction(19.6).divisible(1.5);\n   */\n  \"divisible\": function (a, b) {\n    parse(a, b);\n    if (P['n'] === C_ZERO) return false;\n    return this['n'] * P['d'] % (P['n'] * this['d']) === C_ZERO;\n  },\n  /**\n   * Returns a decimal representation of the fraction\n   *\n   * Ex: new Fraction(\"100.'91823'\").valueOf() => 100.91823918239183\n   **/\n  'valueOf': function () {\n    //if (this['n'] <= MAX_INTEGER && this['d'] <= MAX_INTEGER) {\n    return Number(this['s'] * this['n']) / Number(this['d']);\n    //}\n  },\n  /**\n   * Creates a string representation of a fraction with all digits\n   *\n   * Ex: new Fraction(\"100.'91823'\").toString() => \"100.(91823)\"\n   **/\n  'toString': function () {\n    let dec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    let N = this[\"n\"];\n    let D = this[\"d\"];\n    let cycLen = cycleLen(N, D); // Cycle length\n    let cycOff = cycleStart(N, D, cycLen); // Cycle start\n\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    // Append integer part\n    str += ifloor(N / D);\n    N %= D;\n    N *= C_TEN;\n    if (N) str += \".\";\n    if (cycLen) {\n      for (let i = cycOff; i--;) {\n        str += ifloor(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \"(\";\n      for (let i = cycLen; i--;) {\n        str += ifloor(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \")\";\n    } else {\n      for (let i = dec; N && i--;) {\n        str += ifloor(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n    }\n    return str;\n  },\n  /**\n   * Returns a string-fraction representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toFraction() => \"4 1/3\"\n   **/\n  'toFraction': function () {\n    let showMixed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      const whole = ifloor(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        str += \" \";\n        n %= d;\n      }\n      str += n;\n      str += '/';\n      str += d;\n    }\n    return str;\n  },\n  /**\n   * Returns a latex representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toLatex() => \"\\frac{4}{3}\"\n   **/\n  'toLatex': function () {\n    let showMixed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      const whole = ifloor(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        n %= d;\n      }\n      str += \"\\\\frac{\";\n      str += n;\n      str += '}{';\n      str += d;\n      str += '}';\n    }\n    return str;\n  },\n  /**\n   * Returns an array of continued fraction elements\n   *\n   * Ex: new Fraction(\"7/8\").toContinued() => [0,1,7]\n   */\n  'toContinued': function () {\n    let a = this['n'];\n    let b = this['d'];\n    const res = [];\n    while (b) {\n      res.push(ifloor(a / b));\n      const t = a % b;\n      a = b;\n      b = t;\n    }\n    return res;\n  },\n  \"simplify\": function () {\n    let eps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1e-3;\n    // Continued fractions give best approximations for a max denominator,\n    // generally outperforming mediants in denominator–accuracy trade-offs.\n    // Semiconvergents can further reduce the denominator within tolerance.\n\n    const ieps = BigInt(Math.ceil(1 / eps));\n    const thisABS = this['abs']();\n    const cont = thisABS['toContinued']();\n    for (let i = 1; i < cont.length; i++) {\n      let s = newFraction(cont[i - 1], C_ONE);\n      for (let k = i - 2; k >= 0; k--) {\n        s = s['inverse']()['add'](cont[k]);\n      }\n      let t = s['sub'](thisABS);\n      if (t['n'] * ieps < t['d']) {\n        // More robust than Math.abs(t.valueOf()) < eps\n        return s['mul'](this['s']);\n      }\n    }\n    return this;\n  }\n};\nexport { Fraction as default, Fraction };","map":{"version":3,"names":["BigInt","n","isNaN","Error","C_ZERO","C_ONE","C_TWO","C_THREE","C_FIVE","C_TEN","MAX_INTEGER","Number","MAX_SAFE_INTEGER","MAX_CYCLE_LEN","P","assign","s","e","InvalidParameter","ifloor","x","Math","floor","newFraction","d","DivisionByZero","f","Object","create","Fraction","prototype","a","gcd","FACTORSTEPS","factorize","factors","add","p","si","parse","p1","p2","undefined","NonIntegerParameter","z","A","B","C","D","N","log10","M","ndx","v","w","y","match","replace","length","modpow","b","m","r","cycleLen","rem","t","cycleStart","len","rem1","rem2","abs","neg","sub","mul","div","clone","mod","lcm","inverse","pow","k","log","allPrimes","baseFactors","T1","numberFactors","T2","prime","retN","retD","baseExponent","numberExponent","curN","curD","gcdValue","equals","lt","lte","gt","gte","compare","ceil","places","round","roundTo","divisible","valueOf","toString","dec","arguments","cycLen","cycOff","str","i","toFraction","showMixed","whole","toLatex","toContinued","res","push","simplify","eps","ieps","thisABS","cont","default"],"sources":["/home/xaqanik/test/node_modules/fraction.js/dist/fraction.mjs"],"sourcesContent":["'use strict';\n\n/**\n *\n * This class offers the possibility to calculate fractions.\n * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.\n *\n * Array/Object form\n * [ 0 => <numerator>, 1 => <denominator> ]\n * { n => <numerator>, d => <denominator> }\n *\n * Integer form\n * - Single integer value as BigInt or Number\n *\n * Double form\n * - Single double value as Number\n *\n * String form\n * 123.456 - a simple double\n * 123/456 - a string fraction\n * 123.'456' - a double with repeating decimal places\n * 123.(456) - synonym\n * 123.45'6' - a double with repeating last place\n * 123.45(6) - synonym\n *\n * Example:\n * let f = new Fraction(\"9.4'31'\");\n * f.mul([-4, 3]).div(4.9);\n *\n */\n\n// Set Identity function to downgrade BigInt to Number if needed\nif (typeof BigInt === 'undefined') BigInt = function (n) { if (isNaN(n)) throw new Error(\"\"); return n; };\n\nconst C_ZERO = BigInt(0);\nconst C_ONE = BigInt(1);\nconst C_TWO = BigInt(2);\nconst C_THREE = BigInt(3);\nconst C_FIVE = BigInt(5);\nconst C_TEN = BigInt(10);\nconst MAX_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\n\n// Maximum search depth for cyclic rational numbers. 2000 should be more than enough.\n// Example: 1/7 = 0.(142857) has 6 repeating decimal places.\n// If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits\nconst MAX_CYCLE_LEN = 2000;\n\n// Parsed data to avoid calling \"new\" all the time\nconst P = {\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE\n};\n\nfunction assign(n, s) {\n\n  try {\n    n = BigInt(n);\n  } catch (e) {\n    throw InvalidParameter();\n  }\n  return n * s;\n}\n\nfunction ifloor(x) {\n  return typeof x === 'bigint' ? x : Math.floor(x);\n}\n\n// Creates a new Fraction internally without the need of the bulky constructor\nfunction newFraction(n, d) {\n\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n\n  const f = Object.create(Fraction.prototype);\n  f[\"s\"] = n < C_ZERO ? -C_ONE : C_ONE;\n\n  n = n < C_ZERO ? -n : n;\n\n  const a = gcd(n, d);\n\n  f[\"n\"] = n / a;\n  f[\"d\"] = d / a;\n  return f;\n}\n\nconst FACTORSTEPS = [C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO, C_TWO * C_TWO, C_TWO * C_THREE, C_TWO, C_TWO * C_THREE]; // repeats\nfunction factorize(n) {\n\n  const factors = Object.create(null);\n  if (n <= C_ONE) {\n    factors[n] = C_ONE;\n    return factors;\n  }\n\n  const add = (p) => { factors[p] = (factors[p] || C_ZERO) + C_ONE; };\n\n  while (n % C_TWO === C_ZERO) { add(C_TWO); n /= C_TWO; }\n  while (n % C_THREE === C_ZERO) { add(C_THREE); n /= C_THREE; }\n  while (n % C_FIVE === C_ZERO) { add(C_FIVE); n /= C_FIVE; }\n\n  // 30-wheel trial division: test only residues coprime to 2*3*5\n  // Residue step pattern after 5: 7,11,13,17,19,23,29,31, ...\n  for (let si = 0, p = C_TWO + C_FIVE; p * p <= n;) {\n    while (n % p === C_ZERO) { add(p); n /= p; }\n    p += FACTORSTEPS[si];\n    si = (si + 1) & 7; // fast modulo 8\n  }\n  if (n > C_ONE) add(n);\n  return factors;\n}\n\nconst parse = function (p1, p2) {\n\n  let n = C_ZERO, d = C_ONE, s = C_ONE;\n\n  if (p1 === undefined || p1 === null) { // No argument\n    /* void */\n  } else if (p2 !== undefined) { // Two arguments\n\n    if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else if (isNaN(p1)) {\n      throw InvalidParameter();\n    } else if (p1 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      n = BigInt(p1);\n    }\n\n    if (typeof p2 === \"bigint\") {\n      d = p2;\n    } else if (isNaN(p2)) {\n      throw InvalidParameter();\n    } else if (p2 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      d = BigInt(p2);\n    }\n\n    s = n * d;\n\n  } else if (typeof p1 === \"object\") {\n    if (\"d\" in p1 && \"n\" in p1) {\n      n = BigInt(p1[\"n\"]);\n      d = BigInt(p1[\"d\"]);\n      if (\"s\" in p1)\n        n *= BigInt(p1[\"s\"]);\n    } else if (0 in p1) {\n      n = BigInt(p1[0]);\n      if (1 in p1)\n        d = BigInt(p1[1]);\n    } else if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else {\n      throw InvalidParameter();\n    }\n    s = n * d;\n  } else if (typeof p1 === \"number\") {\n\n    if (isNaN(p1)) {\n      throw InvalidParameter();\n    }\n\n    if (p1 < 0) {\n      s = -C_ONE;\n      p1 = -p1;\n    }\n\n    if (p1 % 1 === 0) {\n      n = BigInt(p1);\n    } else {\n\n      let z = 1;\n\n      let A = 0, B = 1;\n      let C = 1, D = 1;\n\n      let N = 10000000;\n\n      if (p1 >= 1) {\n        z = 10 ** Math.floor(1 + Math.log10(p1));\n        p1 /= z;\n      }\n\n      // Using Farey Sequences\n\n      while (B <= N && D <= N) {\n        let M = (A + C) / (B + D);\n\n        if (p1 === M) {\n          if (B + D <= N) {\n            n = A + C;\n            d = B + D;\n          } else if (D > B) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n          break;\n\n        } else {\n\n          if (p1 > M) {\n            A += C;\n            B += D;\n          } else {\n            C += A;\n            D += B;\n          }\n\n          if (B > N) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n        }\n      }\n      n = BigInt(n) * BigInt(z);\n      d = BigInt(d);\n    }\n\n  } else if (typeof p1 === \"string\") {\n\n    let ndx = 0;\n\n    let v = C_ZERO, w = C_ZERO, x = C_ZERO, y = C_ONE, z = C_ONE;\n\n    let match = p1.replace(/_/g, '').match(/\\d+|./g);\n\n    if (match === null)\n      throw InvalidParameter();\n\n    if (match[ndx] === '-') {// Check for minus sign at the beginning\n      s = -C_ONE;\n      ndx++;\n    } else if (match[ndx] === '+') {// Check for plus sign at the beginning\n      ndx++;\n    }\n\n    if (match.length === ndx + 1) { // Check if it's just a simple number \"1234\"\n      w = assign(match[ndx++], s);\n    } else if (match[ndx + 1] === '.' || match[ndx] === '.') { // Check if it's a decimal number\n\n      if (match[ndx] !== '.') { // Handle 0.5 and .5\n        v = assign(match[ndx++], s);\n      }\n      ndx++;\n\n      // Check for decimal places\n      if (ndx + 1 === match.length || match[ndx + 1] === '(' && match[ndx + 3] === ')' || match[ndx + 1] === \"'\" && match[ndx + 3] === \"'\") {\n        w = assign(match[ndx], s);\n        y = C_TEN ** BigInt(match[ndx].length);\n        ndx++;\n      }\n\n      // Check for repeating places\n      if (match[ndx] === '(' && match[ndx + 2] === ')' || match[ndx] === \"'\" && match[ndx + 2] === \"'\") {\n        x = assign(match[ndx + 1], s);\n        z = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;\n        ndx += 3;\n      }\n\n    } else if (match[ndx + 1] === '/' || match[ndx + 1] === ':') { // Check for a simple fraction \"123/456\" or \"123:456\"\n      w = assign(match[ndx], s);\n      y = assign(match[ndx + 2], C_ONE);\n      ndx += 3;\n    } else if (match[ndx + 3] === '/' && match[ndx + 1] === ' ') { // Check for a complex fraction \"123 1/2\"\n      v = assign(match[ndx], s);\n      w = assign(match[ndx + 2], s);\n      y = assign(match[ndx + 4], C_ONE);\n      ndx += 5;\n    }\n\n    if (match.length <= ndx) { // Check for more tokens on the stack\n      d = y * z;\n      s = /* void */\n        n = x + d * v + z * w;\n    } else {\n      throw InvalidParameter();\n    }\n\n  } else if (typeof p1 === \"bigint\") {\n    n = p1;\n    s = p1;\n    d = C_ONE;\n  } else {\n    throw InvalidParameter();\n  }\n\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n\n  P[\"s\"] = s < C_ZERO ? -C_ONE : C_ONE;\n  P[\"n\"] = n < C_ZERO ? -n : n;\n  P[\"d\"] = d < C_ZERO ? -d : d;\n};\n\nfunction modpow(b, e, m) {\n\n  let r = C_ONE;\n  for (; e > C_ZERO; b = (b * b) % m, e >>= C_ONE) {\n\n    if (e & C_ONE) {\n      r = (r * b) % m;\n    }\n  }\n  return r;\n}\n\nfunction cycleLen(n, d) {\n\n  for (; d % C_TWO === C_ZERO;\n    d /= C_TWO) {\n  }\n\n  for (; d % C_FIVE === C_ZERO;\n    d /= C_FIVE) {\n  }\n\n  if (d === C_ONE) // Catch non-cyclic numbers\n    return C_ZERO;\n\n  // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:\n  // 10^(d-1) % d == 1\n  // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,\n  // as we want to translate the numbers to strings.\n\n  let rem = C_TEN % d;\n  let t = 1;\n\n  for (; rem !== C_ONE; t++) {\n    rem = rem * C_TEN % d;\n\n    if (t > MAX_CYCLE_LEN)\n      return C_ZERO; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`\n  }\n  return BigInt(t);\n}\n\nfunction cycleStart(n, d, len) {\n\n  let rem1 = C_ONE;\n  let rem2 = modpow(C_TEN, len, d);\n\n  for (let t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)\n    // Solve 10^s == 10^(s+t) (mod d)\n\n    if (rem1 === rem2)\n      return BigInt(t);\n\n    rem1 = rem1 * C_TEN % d;\n    rem2 = rem2 * C_TEN % d;\n  }\n  return 0;\n}\n\nfunction gcd(a, b) {\n\n  if (!a)\n    return b;\n  if (!b)\n    return a;\n\n  while (1) {\n    a %= b;\n    if (!a)\n      return b;\n    b %= a;\n    if (!b)\n      return a;\n  }\n}\n\n/**\n * Module constructor\n *\n * @constructor\n * @param {number|Fraction=} a\n * @param {number=} b\n */\nfunction Fraction(a, b) {\n\n  parse(a, b);\n\n  if (this instanceof Fraction) {\n    a = gcd(P[\"d\"], P[\"n\"]); // Abuse a\n    this[\"s\"] = P[\"s\"];\n    this[\"n\"] = P[\"n\"] / a;\n    this[\"d\"] = P[\"d\"] / a;\n  } else {\n    return newFraction(P['s'] * P['n'], P['d']);\n  }\n}\n\nconst DivisionByZero = function () { return new Error(\"Division by Zero\"); };\nconst InvalidParameter = function () { return new Error(\"Invalid argument\"); };\nconst NonIntegerParameter = function () { return new Error(\"Parameters must be integer\"); };\n\nFraction.prototype = {\n\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE,\n\n  /**\n   * Calculates the absolute value\n   *\n   * Ex: new Fraction(-4).abs() => 4\n   **/\n  \"abs\": function () {\n\n    return newFraction(this[\"n\"], this[\"d\"]);\n  },\n\n  /**\n   * Inverts the sign of the current fraction\n   *\n   * Ex: new Fraction(-4).neg() => 4\n   **/\n  \"neg\": function () {\n\n    return newFraction(-this[\"s\"] * this[\"n\"], this[\"d\"]);\n  },\n\n  /**\n   * Adds two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => 467 / 30\n   **/\n  \"add\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * this[\"n\"] * P[\"d\"] + P[\"s\"] * this[\"d\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Subtracts two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => -427 / 30\n   **/\n  \"sub\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * this[\"d\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Multiplies two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").mul(3) => 5776 / 111\n   **/\n  \"mul\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Divides two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").inverse().div(3)\n   **/\n  \"div\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"d\"],\n      this[\"d\"] * P[\"n\"]\n    );\n  },\n\n  /**\n   * Clones the actual object\n   *\n   * Ex: new Fraction(\"-17.(345)\").clone()\n   **/\n  \"clone\": function () {\n    return newFraction(this['s'] * this['n'], this['d']);\n  },\n\n  /**\n   * Calculates the modulo of two rational numbers - a more precise fmod\n   *\n   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)\n   * Ex: new Fraction(20, 10).mod().equals(0) ? \"is Integer\"\n   **/\n  \"mod\": function (a, b) {\n\n    if (a === undefined) {\n      return newFraction(this[\"s\"] * this[\"n\"] % this[\"d\"], C_ONE);\n    }\n\n    parse(a, b);\n    if (C_ZERO === P[\"n\"] * this[\"d\"]) {\n      throw DivisionByZero();\n    }\n\n    /**\n     * I derived the rational modulo similar to the modulo for integers\n     *\n     * https://raw.org/book/analysis/rational-numbers/\n     *\n     *    n1/d1 = (n2/d2) * q + r, where 0 ≤ r < n2/d2\n     * => d2 * n1 = n2 * d1 * q + d1 * d2 * r\n     * => r = (d2 * n1 - n2 * d1 * q) / (d1 * d2)\n     *      = (d2 * n1 - n2 * d1 * floor((d2 * n1) / (n2 * d1))) / (d1 * d2)\n     *      = ((d2 * n1) % (n2 * d1)) / (d1 * d2)\n     */\n    return newFraction(\n      this[\"s\"] * (P[\"d\"] * this[\"n\"]) % (P[\"n\"] * this[\"d\"]),\n      P[\"d\"] * this[\"d\"]);\n  },\n\n  /**\n   * Calculates the fractional gcd of two rational numbers\n   *\n   * Ex: new Fraction(5,8).gcd(3,7) => 1/56\n   */\n  \"gcd\": function (a, b) {\n\n    parse(a, b);\n\n    // https://raw.org/book/analysis/rational-numbers/\n    // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)\n\n    return newFraction(gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]), P[\"d\"] * this[\"d\"]);\n  },\n\n  /**\n   * Calculates the fractional lcm of two rational numbers\n   *\n   * Ex: new Fraction(5,8).lcm(3,7) => 15\n   */\n  \"lcm\": function (a, b) {\n\n    parse(a, b);\n\n    // https://raw.org/book/analysis/rational-numbers/\n    // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)\n\n    if (P[\"n\"] === C_ZERO && this[\"n\"] === C_ZERO) {\n      return newFraction(C_ZERO, C_ONE);\n    }\n    return newFraction(P[\"n\"] * this[\"n\"], gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]));\n  },\n\n  /**\n   * Gets the inverse of the fraction, means numerator and denominator are exchanged\n   *\n   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3\n   **/\n  \"inverse\": function () {\n    return newFraction(this[\"s\"] * this[\"d\"], this[\"n\"]);\n  },\n\n  /**\n   * Calculates the fraction to some integer exponent\n   *\n   * Ex: new Fraction(-1,2).pow(-3) => -8\n   */\n  \"pow\": function (a, b) {\n\n    parse(a, b);\n\n    // Trivial case when exp is an integer\n\n    if (P['d'] === C_ONE) {\n\n      if (P['s'] < C_ZERO) {\n        return newFraction((this['s'] * this[\"d\"]) ** P['n'], this[\"n\"] ** P['n']);\n      } else {\n        return newFraction((this['s'] * this[\"n\"]) ** P['n'], this[\"d\"] ** P['n']);\n      }\n    }\n\n    // Negative roots become complex\n    //     (-a/b)^(c/d) = x\n    // ⇔ (-1)^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula\n    // From which follows that only for c=0 the root is non-complex\n    if (this['s'] < C_ZERO) return null;\n\n    // Now prime factor n and d\n    let N = factorize(this['n']);\n    let D = factorize(this['d']);\n\n    // Exponentiate and take root for n and d individually\n    let n = C_ONE;\n    let d = C_ONE;\n    for (let k in N) {\n      if (k === '1') continue;\n      if (k === '0') {\n        n = C_ZERO;\n        break;\n      }\n      N[k] *= P['n'];\n\n      if (N[k] % P['d'] === C_ZERO) {\n        N[k] /= P['d'];\n      } else return null;\n      n *= BigInt(k) ** N[k];\n    }\n\n    for (let k in D) {\n      if (k === '1') continue;\n      D[k] *= P['n'];\n\n      if (D[k] % P['d'] === C_ZERO) {\n        D[k] /= P['d'];\n      } else return null;\n      d *= BigInt(k) ** D[k];\n    }\n\n    if (P['s'] < C_ZERO) {\n      return newFraction(d, n);\n    }\n    return newFraction(n, d);\n  },\n\n  /**\n   * Calculates the logarithm of a fraction to a given rational base\n   *\n   * Ex: new Fraction(27, 8).log(9, 4) => 3/2\n   */\n  \"log\": function (a, b) {\n\n    parse(a, b);\n\n    if (this['s'] <= C_ZERO || P['s'] <= C_ZERO) return null;\n\n    const allPrimes = Object.create(null);\n\n    const baseFactors = factorize(P['n']);\n    const T1 = factorize(P['d']);\n\n    const numberFactors = factorize(this['n']);\n    const T2 = factorize(this['d']);\n\n    for (const prime in T1) {\n      baseFactors[prime] = (baseFactors[prime] || C_ZERO) - T1[prime];\n    }\n    for (const prime in T2) {\n      numberFactors[prime] = (numberFactors[prime] || C_ZERO) - T2[prime];\n    }\n\n    for (const prime in baseFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n    for (const prime in numberFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n\n    let retN = null;\n    let retD = null;\n\n    // Iterate over all unique primes to determine if a consistent ratio exists\n    for (const prime in allPrimes) {\n\n      const baseExponent = baseFactors[prime] || C_ZERO;\n      const numberExponent = numberFactors[prime] || C_ZERO;\n\n      if (baseExponent === C_ZERO) {\n        if (numberExponent !== C_ZERO) {\n          return null; // Logarithm cannot be expressed as a rational number\n        }\n        continue; // Skip this prime since both exponents are zero\n      }\n\n      // Calculate the ratio of exponents for this prime\n      let curN = numberExponent;\n      let curD = baseExponent;\n\n      // Simplify the current ratio\n      const gcdValue = gcd(curN, curD);\n      curN /= gcdValue;\n      curD /= gcdValue;\n\n      // Check if this is the first ratio; otherwise, ensure ratios are consistent\n      if (retN === null && retD === null) {\n        retN = curN;\n        retD = curD;\n      } else if (curN * retD !== retN * curD) {\n        return null; // Ratios do not match, logarithm cannot be rational\n      }\n    }\n\n    return retN !== null && retD !== null\n      ? newFraction(retN, retD)\n      : null;\n  },\n\n  /**\n   * Check if two rational numbers are the same\n   *\n   * Ex: new Fraction(19.6).equals([98, 5]);\n   **/\n  \"equals\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] === P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is less than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lt\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] < P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is less than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lte\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] <= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is greater than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gt\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] > P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is greater than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gte\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] >= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Compare two rational numbers\n   * < 0 iff this < that\n   * > 0 iff this > that\n   * = 0 iff this = that\n   *\n   * Ex: new Fraction(19.6).compare([98, 5]);\n   **/\n  \"compare\": function (a, b) {\n\n    parse(a, b);\n    let t = this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * P[\"n\"] * this[\"d\"];\n\n    return (C_ZERO < t) - (t < C_ZERO);\n  },\n\n  /**\n   * Calculates the ceil of a rational number\n   *\n   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)\n   **/\n  \"ceil\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    return newFraction(ifloor(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) +\n      (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n   * Calculates the floor of a rational number\n   *\n   * Ex: new Fraction('4.(3)').floor() => (4 / 1)\n   **/\n  \"floor\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    return newFraction(ifloor(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) -\n      (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] < C_ZERO ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n   * Rounds a rational numbers\n   *\n   * Ex: new Fraction('4.(3)').round() => (4 / 1)\n   **/\n  \"round\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    /* Derivation:\n\n    s >= 0:\n      round(n / d) = ifloor(n / d) + (n % d) / d >= 0.5 ? 1 : 0\n                   = ifloor(n / d) + 2(n % d) >= d ? 1 : 0\n    s < 0:\n      round(n / d) =-ifloor(n / d) - (n % d) / d > 0.5 ? 1 : 0\n                   =-ifloor(n / d) - 2(n % d) > d ? 1 : 0\n\n    =>:\n\n    round(s * n / d) = s * ifloor(n / d) + s * (C + 2(n % d) > d ? 1 : 0)\n        where C = s >= 0 ? 1 : 0, to fix the >= for the positve case.\n    */\n\n    return newFraction(ifloor(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) +\n      this[\"s\"] * ((this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this[\"n\"] % this[\"d\"]) > this[\"d\"] ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n    * Rounds a rational number to a multiple of another rational number\n    *\n    * Ex: new Fraction('0.9').roundTo(\"1/8\") => 7 / 8\n    **/\n  \"roundTo\": function (a, b) {\n\n    /*\n    k * x/y ≤ a/b < (k+1) * x/y\n    ⇔ k ≤ a/b / (x/y) < (k+1)\n    ⇔ k = floor(a/b * y/x)\n    ⇔ k = floor((a * y) / (b * x))\n    */\n\n    parse(a, b);\n\n    const n = this['n'] * P['d'];\n    const d = this['d'] * P['n'];\n    const r = n % d;\n\n    // round(n / d) = ifloor(n / d) + 2(n % d) >= d ? 1 : 0\n    let k = ifloor(n / d);\n    if (r + r >= d) {\n      k++;\n    }\n    return newFraction(this['s'] * k * P['n'], P['d']);\n  },\n\n  /**\n   * Check if two rational numbers are divisible\n   *\n   * Ex: new Fraction(19.6).divisible(1.5);\n   */\n  \"divisible\": function (a, b) {\n\n    parse(a, b);\n    if (P['n'] === C_ZERO) return false;\n    return (this['n'] * P['d']) % (P['n'] * this['d']) === C_ZERO;\n  },\n\n  /**\n   * Returns a decimal representation of the fraction\n   *\n   * Ex: new Fraction(\"100.'91823'\").valueOf() => 100.91823918239183\n   **/\n  'valueOf': function () {\n    //if (this['n'] <= MAX_INTEGER && this['d'] <= MAX_INTEGER) {\n    return Number(this['s'] * this['n']) / Number(this['d']);\n    //}\n  },\n\n  /**\n   * Creates a string representation of a fraction with all digits\n   *\n   * Ex: new Fraction(\"100.'91823'\").toString() => \"100.(91823)\"\n   **/\n  'toString': function (dec = 15) {\n\n    let N = this[\"n\"];\n    let D = this[\"d\"];\n\n    let cycLen = cycleLen(N, D); // Cycle length\n    let cycOff = cycleStart(N, D, cycLen); // Cycle start\n\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    // Append integer part\n    str += ifloor(N / D);\n\n    N %= D;\n    N *= C_TEN;\n\n    if (N)\n      str += \".\";\n\n    if (cycLen) {\n\n      for (let i = cycOff; i--;) {\n        str += ifloor(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \"(\";\n      for (let i = cycLen; i--;) {\n        str += ifloor(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \")\";\n    } else {\n      for (let i = dec; N && i--;) {\n        str += ifloor(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n    }\n    return str;\n  },\n\n  /**\n   * Returns a string-fraction representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toFraction() => \"4 1/3\"\n   **/\n  'toFraction': function (showMixed = false) {\n\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      const whole = ifloor(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        str += \" \";\n        n %= d;\n      }\n\n      str += n;\n      str += '/';\n      str += d;\n    }\n    return str;\n  },\n\n  /**\n   * Returns a latex representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toLatex() => \"\\frac{4}{3}\"\n   **/\n  'toLatex': function (showMixed = false) {\n\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      const whole = ifloor(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        n %= d;\n      }\n\n      str += \"\\\\frac{\";\n      str += n;\n      str += '}{';\n      str += d;\n      str += '}';\n    }\n    return str;\n  },\n\n  /**\n   * Returns an array of continued fraction elements\n   *\n   * Ex: new Fraction(\"7/8\").toContinued() => [0,1,7]\n   */\n  'toContinued': function () {\n\n    let a = this['n'];\n    let b = this['d'];\n    const res = [];\n\n    while (b) {\n      res.push(ifloor(a / b));\n      const t = a % b;\n      a = b;\n      b = t;\n    }\n    return res;\n  },\n\n  \"simplify\": function (eps = 1e-3) {\n\n    // Continued fractions give best approximations for a max denominator,\n    // generally outperforming mediants in denominator–accuracy trade-offs.\n    // Semiconvergents can further reduce the denominator within tolerance.\n\n    const ieps = BigInt(Math.ceil(1 / eps));\n\n    const thisABS = this['abs']();\n    const cont = thisABS['toContinued']();\n\n    for (let i = 1; i < cont.length; i++) {\n\n      let s = newFraction(cont[i - 1], C_ONE);\n      for (let k = i - 2; k >= 0; k--) {\n        s = s['inverse']()['add'](cont[k]);\n      }\n\n      let t = s['sub'](thisABS);\n      if (t['n'] * ieps < t['d']) { // More robust than Math.abs(t.valueOf()) < eps\n        return s['mul'](this['s']);\n      }\n    }\n    return this;\n  }\n};\nexport {\n  Fraction as default, Fraction\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}