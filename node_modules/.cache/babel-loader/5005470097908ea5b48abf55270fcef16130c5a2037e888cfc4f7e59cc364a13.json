{"ast":null,"code":"import { pickShallow } from './object.js';\n\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]\n *     Optional object with meta information that will be attached\n *     to the created factory function as property `meta`. For explanation\n *     of what meta properties can be specified and what they mean, see\n *     docs/core/extension.md.\n * @returns {function}\n */\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n  return assertAndCreate;\n}\n\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(factory => {\n    factoriesByName[factory.fn] = factory;\n  });\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (factory.dependencies.includes(dependency.fn || dependency.name)) {\n        return true;\n      }\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var sorted = [];\n  function addFactory(factory) {\n    var index = 0;\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n    sorted.splice(index, 0, factory);\n  }\n\n  // sort regular factory functions\n  factories.filter(isFactory).forEach(addFactory);\n\n  // sort legacy factory functions AFTER the regular factory functions\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\n  return sorted;\n}\n\n// TODO: comment or cleanup if unused in the end\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(factory => factory(scope));\n  return scope;\n}\n\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\n  .every(dependency => scope[dependency] !== undefined);\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined);\n\n    // TODO: create a custom error class for this, a MathjsError or something like that\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","map":{"version":3,"names":["pickShallow","factory","name","dependencies","create","meta","assertAndCreate","scope","deps","map","stripOptionalNotation","assertDependencies","isFactory","fn","slice","sort","sortFactories","factories","factoriesByName","forEach","containsDependency","dependency","includes","some","d","sorted","addFactory","index","length","splice","filter","arguments","undefined","obj","Array","isArray","allDefined","isOptionalDependency","every","missingDependencies","Error","concat","join"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/utils/factory.js"],"sourcesContent":["import { pickShallow } from './object.js';\n\n/**\n * Create a factory function, which can be used to inject dependencies.\n *\n * The created functions are memoized, a consecutive call of the factory\n * with the exact same inputs will return the same function instance.\n * The memoized cache is exposed on `factory.cache` and can be cleared\n * if needed.\n *\n * Example:\n *\n *     const name = 'log'\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\n *\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\n *       // ... create the function log here and return it\n *     }\n *\n * @param {string} name           Name of the function to be created\n * @param {string[]} dependencies The names of all required dependencies\n * @param {function} create       Callback function called with an object with all dependencies\n * @param {Object} [meta]\n *     Optional object with meta information that will be attached\n *     to the created factory function as property `meta`. For explanation\n *     of what meta properties can be specified and what they mean, see\n *     docs/core/extension.md.\n * @returns {function}\n */\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n  return assertAndCreate;\n}\n\n/**\n * Sort all factories such that when loading in order, the dependencies are resolved.\n *\n * @param {Array} factories\n * @returns {Array} Returns a new array with the sorted factories.\n */\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(factory => {\n    factoriesByName[factory.fn] = factory;\n  });\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (factory.dependencies.includes(dependency.fn || dependency.name)) {\n        return true;\n      }\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var sorted = [];\n  function addFactory(factory) {\n    var index = 0;\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n    sorted.splice(index, 0, factory);\n  }\n\n  // sort regular factory functions\n  factories.filter(isFactory).forEach(addFactory);\n\n  // sort legacy factory functions AFTER the regular factory functions\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\n  return sorted;\n}\n\n// TODO: comment or cleanup if unused in the end\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(factory => factory(scope));\n  return scope;\n}\n\n/**\n * Test whether an object is a factory. This is the case when it has\n * properties name, dependencies, and a function create.\n * @param {*} obj\n * @returns {boolean}\n */\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n\n/**\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\n *\n * Will throw an exception when there are dependencies missing.\n *\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\n * @param {string[]} dependencies\n * @param {Object} scope\n */\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\n  .every(dependency => scope[dependency] !== undefined);\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined);\n\n    // TODO: create a custom error class for this, a MathjsError or something like that\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}