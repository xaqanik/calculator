{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'zeta';\nvar dependencies = ['typed', 'config', 'multiply', 'pow', 'divide', 'factorial', 'equal', 'smallerEq', 'isNegative', 'gamma', 'sin', 'subtract', 'add', '?Complex', '?BigNumber', 'pi'];\nexport var createZeta = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    multiply,\n    pow,\n    divide,\n    factorial,\n    equal,\n    smallerEq,\n    isNegative,\n    gamma,\n    sin,\n    subtract,\n    add,\n    Complex,\n    BigNumber: _BigNumber,\n    pi\n  } = _ref;\n  /**\n   * Compute the Riemann Zeta function of a value using an infinite series for\n   * all of the complex plane using Riemann's Functional equation.\n   *\n   * Based off the paper by Xavier Gourdon and Pascal Sebah\n   * ( http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf )\n   *\n   * Implementation and slight modification by Anik Patel\n   *\n   * Note: the implementation is accurate up to about 6 digits.\n   *\n   * Syntax:\n   *\n   *    math.zeta(n)\n   *\n   * Examples:\n   *\n   *    math.zeta(5)       // returns 1.0369277551433895\n   *    math.zeta(-0.5)    // returns -0.2078862249773449\n   *    math.zeta(math.i)  // returns 0.0033002236853253153 - 0.4181554491413212i\n   *\n   * See also:\n   *    erf\n   *\n   * @param {number | Complex | BigNumber} s   A Real, Complex or BigNumber parameter to the Riemann Zeta Function\n   * @return {number | Complex | BigNumber}    The Riemann Zeta of `s`\n   */\n  return typed(name, {\n    number: s => zetaNumeric(s, value => value, () => 20),\n    BigNumber: s => zetaNumeric(s, value => new _BigNumber(value), () => {\n      // relTol is for example 1e-12. Extract the positive exponent 12 from that\n      return Math.abs(Math.log10(config.relTol));\n    }),\n    Complex: zetaComplex\n  });\n\n  /**\n   * @param {number | BigNumber} s\n   * @param {(value: number) => number | BigNumber} createValue\n   * @param {(value: number | BigNumber | Complex) => number} determineDigits\n   * @returns {number | BigNumber}\n   */\n  function zetaNumeric(s, createValue, determineDigits) {\n    if (equal(s, 0)) {\n      return createValue(-0.5);\n    }\n    if (equal(s, 1)) {\n      return createValue(NaN);\n    }\n    if (!isFinite(s)) {\n      return isNegative(s) ? createValue(NaN) : createValue(1);\n    }\n    return zeta(s, createValue, determineDigits, s => s);\n  }\n\n  /**\n   * @param {Complex} s\n   * @returns {Complex}\n   */\n  function zetaComplex(s) {\n    if (s.re === 0 && s.im === 0) {\n      return new Complex(-0.5);\n    }\n    if (s.re === 1) {\n      return new Complex(NaN, NaN);\n    }\n    if (s.re === Infinity && s.im === 0) {\n      return new Complex(1);\n    }\n    if (s.im === Infinity || s.re === -Infinity) {\n      return new Complex(NaN, NaN);\n    }\n    return zeta(s, value => value, s => Math.round(1.3 * 15 + 0.9 * Math.abs(s.im)), s => s.re);\n  }\n\n  /**\n   * @param {number | BigNumber | Complex} s\n   * @param {(value: number) => number | BigNumber | Complex} createValue\n   * @param {(value: number | BigNumber | Complex) => number} determineDigits\n   * @param {(value: number | BigNumber | Complex) => number} getRe\n   * @returns {*|number}\n   */\n  function zeta(s, createValue, determineDigits, getRe) {\n    var n = determineDigits(s);\n    if (getRe(s) > -(n - 1) / 2) {\n      return f(s, createValue(n), createValue);\n    } else {\n      // Function Equation for reflection to x < 1\n      var c = multiply(pow(2, s), pow(createValue(pi), subtract(s, 1)));\n      c = multiply(c, sin(multiply(divide(createValue(pi), 2), s)));\n      c = multiply(c, gamma(subtract(1, s)));\n      return multiply(c, zeta(subtract(1, s), createValue, determineDigits, getRe));\n    }\n  }\n\n  /**\n   * Calculate a portion of the sum\n   * @param {number | BigNumber} k   a positive integer\n   * @param {number | BigNumber} n   a positive integer\n   * @return {number}    the portion of the sum\n   **/\n  function d(k, n) {\n    var S = k;\n    for (var j = k; smallerEq(j, n); j = add(j, 1)) {\n      var factor = divide(multiply(factorial(add(n, subtract(j, 1))), pow(4, j)), multiply(factorial(subtract(n, j)), factorial(multiply(2, j))));\n      S = add(S, factor);\n    }\n    return multiply(n, S);\n  }\n\n  /**\n   * Calculate the positive Riemann Zeta function\n   * @param {number} s   a real or complex number with s.re > 1\n   * @param {number} n   a positive integer\n   * @param {(number) => number | BigNumber | Complex} createValue\n   * @return {number}    Riemann Zeta of s\n   **/\n  function f(s, n, createValue) {\n    var c = divide(1, multiply(d(createValue(0), n), subtract(1, pow(2, subtract(1, s)))));\n    var S = createValue(0);\n    for (var k = createValue(1); smallerEq(k, n); k = add(k, 1)) {\n      S = add(S, divide(multiply((-1) ** (k - 1), d(k, n)), pow(k, s)));\n    }\n    return multiply(c, S);\n  }\n});","map":{"version":3,"names":["factory","name","dependencies","createZeta","_ref","typed","config","multiply","pow","divide","factorial","equal","smallerEq","isNegative","gamma","sin","subtract","add","Complex","BigNumber","_BigNumber","pi","number","s","zetaNumeric","value","Math","abs","log10","relTol","zetaComplex","createValue","determineDigits","NaN","isFinite","zeta","re","im","Infinity","round","getRe","n","f","c","d","k","S","j","factor"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/function/special/zeta.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'zeta';\nvar dependencies = ['typed', 'config', 'multiply', 'pow', 'divide', 'factorial', 'equal', 'smallerEq', 'isNegative', 'gamma', 'sin', 'subtract', 'add', '?Complex', '?BigNumber', 'pi'];\nexport var createZeta = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    multiply,\n    pow,\n    divide,\n    factorial,\n    equal,\n    smallerEq,\n    isNegative,\n    gamma,\n    sin,\n    subtract,\n    add,\n    Complex,\n    BigNumber: _BigNumber,\n    pi\n  } = _ref;\n  /**\n   * Compute the Riemann Zeta function of a value using an infinite series for\n   * all of the complex plane using Riemann's Functional equation.\n   *\n   * Based off the paper by Xavier Gourdon and Pascal Sebah\n   * ( http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf )\n   *\n   * Implementation and slight modification by Anik Patel\n   *\n   * Note: the implementation is accurate up to about 6 digits.\n   *\n   * Syntax:\n   *\n   *    math.zeta(n)\n   *\n   * Examples:\n   *\n   *    math.zeta(5)       // returns 1.0369277551433895\n   *    math.zeta(-0.5)    // returns -0.2078862249773449\n   *    math.zeta(math.i)  // returns 0.0033002236853253153 - 0.4181554491413212i\n   *\n   * See also:\n   *    erf\n   *\n   * @param {number | Complex | BigNumber} s   A Real, Complex or BigNumber parameter to the Riemann Zeta Function\n   * @return {number | Complex | BigNumber}    The Riemann Zeta of `s`\n   */\n  return typed(name, {\n    number: s => zetaNumeric(s, value => value, () => 20),\n    BigNumber: s => zetaNumeric(s, value => new _BigNumber(value), () => {\n      // relTol is for example 1e-12. Extract the positive exponent 12 from that\n      return Math.abs(Math.log10(config.relTol));\n    }),\n    Complex: zetaComplex\n  });\n\n  /**\n   * @param {number | BigNumber} s\n   * @param {(value: number) => number | BigNumber} createValue\n   * @param {(value: number | BigNumber | Complex) => number} determineDigits\n   * @returns {number | BigNumber}\n   */\n  function zetaNumeric(s, createValue, determineDigits) {\n    if (equal(s, 0)) {\n      return createValue(-0.5);\n    }\n    if (equal(s, 1)) {\n      return createValue(NaN);\n    }\n    if (!isFinite(s)) {\n      return isNegative(s) ? createValue(NaN) : createValue(1);\n    }\n    return zeta(s, createValue, determineDigits, s => s);\n  }\n\n  /**\n   * @param {Complex} s\n   * @returns {Complex}\n   */\n  function zetaComplex(s) {\n    if (s.re === 0 && s.im === 0) {\n      return new Complex(-0.5);\n    }\n    if (s.re === 1) {\n      return new Complex(NaN, NaN);\n    }\n    if (s.re === Infinity && s.im === 0) {\n      return new Complex(1);\n    }\n    if (s.im === Infinity || s.re === -Infinity) {\n      return new Complex(NaN, NaN);\n    }\n    return zeta(s, value => value, s => Math.round(1.3 * 15 + 0.9 * Math.abs(s.im)), s => s.re);\n  }\n\n  /**\n   * @param {number | BigNumber | Complex} s\n   * @param {(value: number) => number | BigNumber | Complex} createValue\n   * @param {(value: number | BigNumber | Complex) => number} determineDigits\n   * @param {(value: number | BigNumber | Complex) => number} getRe\n   * @returns {*|number}\n   */\n  function zeta(s, createValue, determineDigits, getRe) {\n    var n = determineDigits(s);\n    if (getRe(s) > -(n - 1) / 2) {\n      return f(s, createValue(n), createValue);\n    } else {\n      // Function Equation for reflection to x < 1\n      var c = multiply(pow(2, s), pow(createValue(pi), subtract(s, 1)));\n      c = multiply(c, sin(multiply(divide(createValue(pi), 2), s)));\n      c = multiply(c, gamma(subtract(1, s)));\n      return multiply(c, zeta(subtract(1, s), createValue, determineDigits, getRe));\n    }\n  }\n\n  /**\n   * Calculate a portion of the sum\n   * @param {number | BigNumber} k   a positive integer\n   * @param {number | BigNumber} n   a positive integer\n   * @return {number}    the portion of the sum\n   **/\n  function d(k, n) {\n    var S = k;\n    for (var j = k; smallerEq(j, n); j = add(j, 1)) {\n      var factor = divide(multiply(factorial(add(n, subtract(j, 1))), pow(4, j)), multiply(factorial(subtract(n, j)), factorial(multiply(2, j))));\n      S = add(S, factor);\n    }\n    return multiply(n, S);\n  }\n\n  /**\n   * Calculate the positive Riemann Zeta function\n   * @param {number} s   a real or complex number with s.re > 1\n   * @param {number} n   a positive integer\n   * @param {(number) => number | BigNumber | Complex} createValue\n   * @return {number}    Riemann Zeta of s\n   **/\n  function f(s, n, createValue) {\n    var c = divide(1, multiply(d(createValue(0), n), subtract(1, pow(2, subtract(1, s)))));\n    var S = createValue(0);\n    for (var k = createValue(1); smallerEq(k, n); k = add(k, 1)) {\n      S = add(S, divide(multiply((-1) ** (k - 1), d(k, n)), pow(k, s)));\n    }\n    return multiply(c, S);\n  }\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}