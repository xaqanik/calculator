{"ast":null,"code":"import { createBitOr } from '../../function/bitwise/bitOr.js';\nimport { factory } from '../../utils/factory.js';\nimport { isCollection } from '../../utils/is.js';\nvar name = 'bitOr';\nvar dependencies = ['typed', 'matrix', 'equalScalar', 'DenseMatrix', 'concat'];\nexport var createBitOrTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    equalScalar,\n    DenseMatrix,\n    concat\n  } = _ref;\n  var bitOr = createBitOr({\n    typed,\n    matrix,\n    equalScalar,\n    DenseMatrix,\n    concat\n  });\n  function bitOrTransform(args, math, scope) {\n    var condition1 = args[0].compile().evaluate(scope);\n    if (!isCollection(condition1)) {\n      if (isNaN(condition1)) {\n        return NaN;\n      }\n      if (condition1 === -1) {\n        return -1;\n      }\n      if (condition1 === true) {\n        return 1;\n      }\n    }\n    var condition2 = args[1].compile().evaluate(scope);\n    return bitOr(condition1, condition2);\n  }\n  bitOrTransform.rawArgs = true;\n  return bitOrTransform;\n}, {\n  isTransformFunction: true\n});","map":{"version":3,"names":["createBitOr","factory","isCollection","name","dependencies","createBitOrTransform","_ref","typed","matrix","equalScalar","DenseMatrix","concat","bitOr","bitOrTransform","args","math","scope","condition1","compile","evaluate","isNaN","NaN","condition2","rawArgs","isTransformFunction"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/expression/transform/bitOr.transform.js"],"sourcesContent":["import { createBitOr } from '../../function/bitwise/bitOr.js';\nimport { factory } from '../../utils/factory.js';\nimport { isCollection } from '../../utils/is.js';\nvar name = 'bitOr';\nvar dependencies = ['typed', 'matrix', 'equalScalar', 'DenseMatrix', 'concat'];\nexport var createBitOrTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    equalScalar,\n    DenseMatrix,\n    concat\n  } = _ref;\n  var bitOr = createBitOr({\n    typed,\n    matrix,\n    equalScalar,\n    DenseMatrix,\n    concat\n  });\n  function bitOrTransform(args, math, scope) {\n    var condition1 = args[0].compile().evaluate(scope);\n    if (!isCollection(condition1)) {\n      if (isNaN(condition1)) {\n        return NaN;\n      }\n      if (condition1 === -1) {\n        return -1;\n      }\n      if (condition1 === true) {\n        return 1;\n      }\n    }\n    var condition2 = args[1].compile().evaluate(scope);\n    return bitOr(condition1, condition2);\n  }\n  bitOrTransform.rawArgs = true;\n  return bitOrTransform;\n}, {\n  isTransformFunction: true\n});"],"mappings":"AAAA,SAASA,WAAW,QAAQ,iCAAiC;AAC7D,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,YAAY,QAAQ,mBAAmB;AAChD,IAAIC,IAAI,GAAG,OAAO;AAClB,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,aAAa,EAAE,aAAa,EAAE,QAAQ,CAAC;AAC9E,OAAO,IAAIC,oBAAoB,GAAG,eAAeJ,OAAO,CAACE,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EACnF,IAAI;IACFC,KAAK;IACLC,MAAM;IACNC,WAAW;IACXC,WAAW;IACXC;EACF,CAAC,GAAGL,IAAI;EACR,IAAIM,KAAK,GAAGZ,WAAW,CAAC;IACtBO,KAAK;IACLC,MAAM;IACNC,WAAW;IACXC,WAAW;IACXC;EACF,CAAC,CAAC;EACF,SAASE,cAAcA,CAACC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;IACzC,IAAIC,UAAU,GAAGH,IAAI,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACH,KAAK,CAAC;IAClD,IAAI,CAACd,YAAY,CAACe,UAAU,CAAC,EAAE;MAC7B,IAAIG,KAAK,CAACH,UAAU,CAAC,EAAE;QACrB,OAAOI,GAAG;MACZ;MACA,IAAIJ,UAAU,KAAK,CAAC,CAAC,EAAE;QACrB,OAAO,CAAC,CAAC;MACX;MACA,IAAIA,UAAU,KAAK,IAAI,EAAE;QACvB,OAAO,CAAC;MACV;IACF;IACA,IAAIK,UAAU,GAAGR,IAAI,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACH,KAAK,CAAC;IAClD,OAAOJ,KAAK,CAACK,UAAU,EAAEK,UAAU,CAAC;EACtC;EACAT,cAAc,CAACU,OAAO,GAAG,IAAI;EAC7B,OAAOV,cAAc;AACvB,CAAC,EAAE;EACDW,mBAAmB,EAAE;AACvB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}