{"ast":null,"code":"import { createAnd } from '../../function/logical/and.js';\nimport { factory } from '../../utils/factory.js';\nimport { isCollection } from '../../utils/is.js';\nvar name = 'and';\nvar dependencies = ['typed', 'matrix', 'zeros', 'add', 'equalScalar', 'not', 'concat'];\nexport var createAndTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    equalScalar,\n    zeros,\n    not,\n    concat\n  } = _ref;\n  var and = createAnd({\n    typed,\n    matrix,\n    equalScalar,\n    zeros,\n    not,\n    concat\n  });\n  function andTransform(args, math, scope) {\n    var condition1 = args[0].compile().evaluate(scope);\n    if (!isCollection(condition1) && !and(condition1, true)) {\n      return false;\n    }\n    var condition2 = args[1].compile().evaluate(scope);\n    return and(condition1, condition2);\n  }\n  andTransform.rawArgs = true;\n  return andTransform;\n}, {\n  isTransformFunction: true\n});","map":{"version":3,"names":["createAnd","factory","isCollection","name","dependencies","createAndTransform","_ref","typed","matrix","equalScalar","zeros","not","concat","and","andTransform","args","math","scope","condition1","compile","evaluate","condition2","rawArgs","isTransformFunction"],"sources":["/home/xaqanik/test/node_modules/mathjs/lib/esm/expression/transform/and.transform.js"],"sourcesContent":["import { createAnd } from '../../function/logical/and.js';\nimport { factory } from '../../utils/factory.js';\nimport { isCollection } from '../../utils/is.js';\nvar name = 'and';\nvar dependencies = ['typed', 'matrix', 'zeros', 'add', 'equalScalar', 'not', 'concat'];\nexport var createAndTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    equalScalar,\n    zeros,\n    not,\n    concat\n  } = _ref;\n  var and = createAnd({\n    typed,\n    matrix,\n    equalScalar,\n    zeros,\n    not,\n    concat\n  });\n  function andTransform(args, math, scope) {\n    var condition1 = args[0].compile().evaluate(scope);\n    if (!isCollection(condition1) && !and(condition1, true)) {\n      return false;\n    }\n    var condition2 = args[1].compile().evaluate(scope);\n    return and(condition1, condition2);\n  }\n  andTransform.rawArgs = true;\n  return andTransform;\n}, {\n  isTransformFunction: true\n});"],"mappings":"AAAA,SAASA,SAAS,QAAQ,+BAA+B;AACzD,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,YAAY,QAAQ,mBAAmB;AAChD,IAAIC,IAAI,GAAG,KAAK;AAChB,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,aAAa,EAAE,KAAK,EAAE,QAAQ,CAAC;AACtF,OAAO,IAAIC,kBAAkB,GAAG,eAAeJ,OAAO,CAACE,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EACjF,IAAI;IACFC,KAAK;IACLC,MAAM;IACNC,WAAW;IACXC,KAAK;IACLC,GAAG;IACHC;EACF,CAAC,GAAGN,IAAI;EACR,IAAIO,GAAG,GAAGb,SAAS,CAAC;IAClBO,KAAK;IACLC,MAAM;IACNC,WAAW;IACXC,KAAK;IACLC,GAAG;IACHC;EACF,CAAC,CAAC;EACF,SAASE,YAAYA,CAACC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;IACvC,IAAIC,UAAU,GAAGH,IAAI,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACH,KAAK,CAAC;IAClD,IAAI,CAACf,YAAY,CAACgB,UAAU,CAAC,IAAI,CAACL,GAAG,CAACK,UAAU,EAAE,IAAI,CAAC,EAAE;MACvD,OAAO,KAAK;IACd;IACA,IAAIG,UAAU,GAAGN,IAAI,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACH,KAAK,CAAC;IAClD,OAAOJ,GAAG,CAACK,UAAU,EAAEG,UAAU,CAAC;EACpC;EACAP,YAAY,CAACQ,OAAO,GAAG,IAAI;EAC3B,OAAOR,YAAY;AACrB,CAAC,EAAE;EACDS,mBAAmB,EAAE;AACvB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}